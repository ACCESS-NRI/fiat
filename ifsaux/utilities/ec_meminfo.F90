SUBROUTINE EC_MEMINFO(KU,CDSTRING,KCOMM,KBARR,KIOTASK)

USE PARKIND1, ONLY : JPIM, JPIB, JPRD
USE MPL_MPIF

IMPLICIT NONE

!-- EC_MEMINFO:
!   Author   : Peter Towers (ECMWF)  : 2015-2016
!   Modified : Sami Saarinen (ECMWF) : 21-SEP-2016 : Added getenv EC_MEMINFO -- export EC_MEMINFO=0 disables any EC_MEMINFO output
!              Sami Saarinen (ECMWF) : 02-MAR-2017 : Enabled flexible number of sockets & lots of tidying

INTEGER(KIND=JPIM), INTENT(IN) :: KU,KCOMM,KBARR,KIOTASK
CHARACTER(LEN=*), INTENT(IN) :: CDSTRING
INTEGER(KIND=JPIM) :: ID,KULOUT
INTEGER(KIND=JPIM) :: II,I,J,K,MYPROC,NPROC,LEN,ERROR,ITAG,NODENUM
INTEGER(KIND=JPIB) :: TASKSMALL,NODEHUGE,MEMFREE,CACHED,NFREE
INTEGER(KIND=JPIB),SAVE :: NODEHUGE_CACHED
INTEGER(KIND=JPIM), PARAMETER :: MAXNUMA = 4 ! Max number of "sockets" supported
INTEGER(KIND=JPIM) :: NNUMA ! Actual number of "sockets"
INTEGER(KIND=JPIB),DIMENSION(0:MAXNUMA-1) :: SMALLPAGE,HUGEPAGE
INTEGER(KIND=JPIB) :: GETMAXRSS,GETMAXHWM
INTEGER(KIND=JPIB) :: HEAP_SIZE
INTEGER(KIND=JPIB), PARAMETER :: ONEMEGA = 1024_JPIB * 1024_JPIB
INTEGER(KIND=JPIM),SAVE :: PAGESIZE = 0
INTEGER(KIND=JPIM),PARAMETER :: MAXCOLS = 18 ! Max numerical columns in /proc/buddyinfo (often just 11, but Cray has 18 entries)
INTEGER(KIND=JPIM) :: N18
INTEGER(KIND=JPIB),DIMENSION(0:MAXCOLS-1,0:MAXNUMA-1) :: NODE, BUCKET
INTEGER(KIND=JPIB),DIMENSION(5+2*MAXNUMA) :: SENDBUF,RECVBUF
REAL(KIND=JPRD) :: PERCENT_USED(2)
CHARACTER(LEN=512) :: TMPDIR
CHARACTER(LEN=512) :: PROGRAM
CHARACTER(LEN=12)  :: NODENAME,LASTNODE
CHARACTER(LEN=12)  :: VAL
CHARACTER(LEN=1)   :: M
CHARACTER(LEN=160) ::LINE
CHARACTER(LEN=56) :: FILENAME
CHARACTER(LEN=2) :: CLEC_MEMINFO
CHARACTER(LEN=4) :: CSTAR
CHARACTER(LEN=LEN(CSTAR)+1+LEN(CDSTRING)) :: ID_STRING
CHARACTER(LEN=10) ::  CLDATEOD,CLTIMEOD,CLZONEOD
CHARACTER(LEN=3), PARAMETER :: CLMON(1:12) = (/ &
     'Jan','Feb','Mar','Apr','May','Jun', &
     'Jul','Aug','Sep','Oct','Nov','Dec' /)
INTEGER(KIND=JPIM) :: IVALUES(8), IMON
INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLNOCOMM, LLNOHDR
LOGICAL, SAVE :: LLFIRST_TIME = .TRUE.
TYPE RANKNODE_T
   INTEGER(KIND=JPIM) :: NODENUM
   INTEGER(KIND=JPIM) :: RANK
   INTEGER(KIND=JPIM) :: IORANK
   CHARACTER(LEN=LEN(NODENAME)) :: NODE
END TYPE
TYPE (RANKNODE_T), ALLOCATABLE, SAVE :: RN(:)
INTEGER(KIND=JPIM), ALLOCATABLE, SAVE :: IDX(:)
INTEGER(KIND=JPIM), SAVE :: NUMNODES = 0
INTEGER(KIND=JPIM), SAVE :: IOTASKS = 0
INTEGER(KIND=JPIM) :: IORANK
REAL(KIND=JPRD), EXTERNAL :: UTIL_WALLTIME
REAL(KIND=JPRD), SAVE :: WT0
REAL(KIND=JPRD) :: WT
CHARACTER(LEN=64) :: CLPFX
CHARACTER(LEN=3) :: ZUM
INTEGER(KIND=JPIM) :: IPFXLEN
INTEGER OMP_GET_MAX_THREADS
#ifdef _OPENMP
EXTERNAL OMP_GET_MAX_THREADS
#else
OMP_GET_MAX_THREADS() = 1
#endif

CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO',CLEC_MEMINFO)
IF (CLEC_MEMINFO == '0') RETURN

IF (PAGESIZE == 0) WT0 = UTIL_WALLTIME()

LLNOCOMM = (KCOMM == -1 .or. KCOMM == -2)
LLNOHDR = (KCOMM == -2)

CALL FLUSH(0)

IF (LLNOCOMM) THEN
   ! Direct call to obtain EC_meminfo -output
   ERROR = 0
   MYPROC = 0
   NPROC = 1
   CLPFX = CDSTRING
   IPFXLEN = LEN_TRIM(CLPFX)
   ZUM = 'tsk'
ELSE
   CLPFX = ' '
   IPFXLEN = 0
   ZUM = 'sum'
   CALL CONDBARR()
   CALL CHECK_ERROR("from MPI_BARRIER(at start)",__FILE__,__LINE__)
   
   CALL MPI_COMM_RANK(KCOMM,MYPROC,ERROR)
   CALL CHECK_ERROR("from MPI_COMM_RANK",__FILE__,__LINE__)

   CALL MPI_COMM_SIZE(KCOMM,NPROC,ERROR)
   CALL CHECK_ERROR("from MPI_COMM_SIZE",__FILE__,__LINE__)
ENDIF

CALL EC_GETHOSTNAME(NODENAME) ! from support/env.c

IF (PAGESIZE == 0) THEN ! First time
   PAGESIZE=2048
   CALL GET_ENVIRONMENT_VARIABLE("HUGETLB_DEFAULT_PAGE_SIZE",VAL)
   I=INDEX(VAL,"M")
   IF(I > 0) THEN
      READ(VAL(1:I-1),*) PAGESIZE
      PAGESIZE=PAGESIZE*1024
   ENDIF

   NODEHUGE=0
   
   WRITE(FILENAME,'(a,i0,a)') "/sys/kernel/mm/hugepages/hugepages-", &
        PAGESIZE,"kB/nr_hugepages"

   IF(PAGESIZE > 0) THEN
      OPEN(502,FILE=FILENAME,STATUS="old")
      READ(502,*) NODEHUGE
      CLOSE(502)
   ENDIF

   NODEHUGE=NODEHUGE*PAGESIZE
   NODEHUGE=NODEHUGE/1024
   NODEHUGE_CACHED = NODEHUGE
ENDIF

NODEHUGE=NODEHUGE_CACHED

IF (NODEHUGE < 1000) THEN
   CSTAR = " s/p"
ELSE
   CSTAR = " H/p"
ENDIF
   
MEMFREE = 0
CACHED = 0
      
OPEN(FILE="/proc/meminfo",UNIT=502)
DO I=1,10
  READ(502,'(a)') LINE
  IF(LINE(1:7) == "MemFree") THEN
    READ(LINE(9:80),*) MEMFREE 
  ELSEIF(LINE(1:6) == "Cached") THEN
    READ(LINE(8:80),*) CACHED
  ENDIF
ENDDO
CLOSE(502)

MEMFREE=MEMFREE/1024
CACHED=CACHED/1024

TASKSMALL=GETMAXRSS()/ONEMEGA

OPEN(FILE="/proc/buddyinfo",UNIT=502)

N18 = 0 ! number of buddy columns (up to MAXCOLS)
NNUMA = 0 ! number of NUMA-nodes (up to MAXNUMA)
READ(502,'(a)') LINE
READ(502,'(a)') LINE
READ(502,'(a)') LINE
NODE(:,0)=-1
READ(LINE(22:),*,END=98) NODE(:,0)
98 CONTINUE
N18 = COUNT(NODE(:,0) >= 0)
NNUMA = 1
DO K=1,MAXNUMA-1
   NODE(:,K)=0
   READ(502,'(a)',END=99) LINE
   READ(LINE(22:),*) NODE(0:N18-1,K)
   NNUMA = NNUMA + 1
ENDDO

99 CONTINUE
CLOSE(502)

SMALLPAGE(:) = 0
HUGEPAGE(:) = 0
DO K=0,NNUMA-1
   BUCKET(:,K) = 0
   DO J=0,N18-1
      BUCKET(J,K) = 4096_JPIB * NODE(J,K) * (2_JPIB ** J)
   ENDDO
   SMALLPAGE(K) = SUM(BUCKET(0:8,K))/ONEMEGA
   HUGEPAGE(K) = SUM(BUCKET(9:N18-1,K))/ONEMEGA
ENDDO

HEAP_SIZE=GETMAXHWM()/ONEMEGA

ITAG = 98765

IF (NPROC > 1 .and. LLFIRST_TIME) THEN
   IORANK = 0
   IF (KIOTASK > 0) IORANK = 1
   IF (MYPROC == 0) THEN
!      DO K=0,NNUMA-1
!         write(6,*) '== NUMA#',K
!         write(6,*) 'SMALLPAGE=',SMALLPAGE(K)
!         write(6,'(1X,A,9(1X,I0))') 'BUCKET(0:8)=',BUCKET(0:8,K)
!         write(6,*) ' HUGEPAGE=', HUGEPAGE(K)
!         write(6,'(1X,A,I0,A,9(1X,I0))') 'BUCKET(9:',N18,')=',BUCKET(9:N18,K)
!      ENDDO
!      call flush(6)
      ALLOCATE(RN(0:NPROC-1))
      LASTNODE=NODENAME
      DO I=0,NPROC-1
         RN(I)%NODENUM = -1
         IF (I > 0) THEN ! Receive in MPI-rank order
            CALL MPI_RECV(LASTNODE,LEN(LASTNODE),MPI_BYTE,I,ITAG,KCOMM,IRECV_STATUS,ERROR)
            CALL CHECK_ERROR("from MPI_RECV(LASTNODE)",__FILE__,__LINE__)
            CALL MPI_RECV(IORANK,1,MPI_INTEGER4,I,ITAG+1,KCOMM,IRECV_STATUS,ERROR)
            CALL CHECK_ERROR("from MPI_RECV(IORANK)",__FILE__,__LINE__)
            RN(I)%RANK = I
         ELSE
            RN(I)%RANK = 0 ! Itself
         ENDIF
         RN(I)%IORANK = IORANK
         RN(I)%NODE = LASTNODE
      ENDDO
      CALL RNSORT
      LLFIRST_TIME = .FALSE.
      CALL CONDBARR()
      CALL CHECK_ERROR("from MPI_BARRIER(LASTNODE)",__FILE__,__LINE__)
   ENDIF
ENDIF

IF (MYPROC == 0) THEN 
  CALL GETARG(0,PROGRAM)
!
! Use already open file for output or $EC_MEMINFO_TMPDIR/meminfo
! We do not use $TMPDIR as it may have been inherited from mother superiour (MOMS) node
!
  IF(KU == -1) THEN
    CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_TMPDIR',TMPDIR)
    IF (TMPDIR == ' ') TMPDIR = '.'
!    write(0,*) '## EC_MEMINFO: KCOMM=',KCOMM
!    CALL LINUX_TRBK()
    KULOUT=501
    OPEN(UNIT=KULOUT,FILE=TRIM(TMPDIR)//"/"//"meminfo",STATUS='unknown', &
         ACTION='write',POSITION='append')
  ELSE
    KULOUT=KU
  ENDIF

  CALL DATE_AND_TIME(CLDATEOD,CLTIMEOD,CLZONEOD,IVALUES)
  READ(CLDATEOD(5:6),'(I2)') IMON

  IF (.not.LLNOCOMM) CALL PRT_DETAIL(KULOUT)
  IF (.not.LLNOHDR)  CALL PRT_HDR(KULOUT)
  IF(KU == -1) THEN
     CALL PRT_DETAIL(0)
     CALL PRT_HDR(0)
  ENDIF
ENDIF

IF (MYPROC == 0) THEN
    NODENUM=1
    LASTNODE = NODENAME
    DO II=1,NPROC-1
        K = IDX(II)
        I = RN(K)%RANK
        CALL MPI_RECV(RECVBUF,SIZE(RECVBUF),MPI_INTEGER8,I,ITAG+2,KCOMM,IRECV_STATUS,ERROR)
        CALL CHECK_ERROR("from MPI_RECV(RECVBUF)",__FILE__,__LINE__)
        NODENAME = RN(K)%NODE
        IF(LASTNODE==NODENAME)THEN
          HEAP_SIZE=HEAP_SIZE+RECVBUF(4)
          TASKSMALL=TASKSMALL+RECVBUF(5)
        ELSE
          PERCENT_USED(2) = 0
          IF(HEAP_SIZE >= NODEHUGE) THEN
! running with small pages
            PERCENT_USED(1)=100.0*(TASKSMALL+NODEHUGE)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
          ELSE
! running with huge pages
            PERCENT_USED(1)=100.0*(HEAP_SIZE+TASKSMALL)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
            IF (NODEHUGE > 0) THEN
               NFREE = SUM(HUGEPAGE(0:NNUMA-1))
               PERCENT_USED(2) = (100.0*(NODEHUGE - NFREE))/NODEHUGE
               IF (PERCENT_USED(2) < 0) PERCENT_USED(2) = 0
               IF (PERCENT_USED(2) > 100) PERCENT_USED(2) = 100
            ENDIF
          ENDIF
          IF (.not.LLNOCOMM) THEN
             ID_STRING = CSTAR//":"//CDSTRING
          ELSE
             ID_STRING = CSTAR
          ENDIF
          CALL PRT_DATA(KULOUT)
          IF(KU == -1) CALL PRT_DATA(0)

          NODEHUGE=RECVBUF(1)
          MEMFREE=RECVBUF(2)
          CACHED=RECVBUF(3)
          HEAP_SIZE=RECVBUF(4)
          TASKSMALL=RECVBUF(5)
          DO K=0,MAXNUMA-1
             SMALLPAGE(K) = RECVBUF(5+2*K+1)
             HUGEPAGE(K) = RECVBUF(5+2*K+2)
          ENDDO
          NODENUM=NODENUM+1
          LASTNODE=NODENAME
        ENDIF
    ENDDO
    PERCENT_USED(2) = 0
    IF(HEAP_SIZE >= NODEHUGE) THEN
! running with small pages
      PERCENT_USED(1)=100.0*(TASKSMALL+NODEHUGE)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
    ELSE
! running with huge pages
      PERCENT_USED(1)=100.0*(HEAP_SIZE+TASKSMALL)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
      IF (NODEHUGE > 0) THEN
         NFREE = SUM(HUGEPAGE(0:NNUMA-1))
         PERCENT_USED(2) = (100.0*(NODEHUGE - NFREE))/NODEHUGE
         IF (PERCENT_USED(2) < 0) PERCENT_USED(2) = 0
         IF (PERCENT_USED(2) > 100) PERCENT_USED(2) = 100
      ENDIF
    ENDIF
    IF (.not.LLNOCOMM) THEN
       ID_STRING = CSTAR//":"//CDSTRING
    ELSE
       ID_STRING = CSTAR
    ENDIF
    CALL PRT_DATA(KULOUT)
    IF(KU == -1) THEN
       CALL PRT_DATA(0)
       CALL PRT_EMPTY(KULOUT,1)
       CLOSE(KULOUT)
    ENDIF
ELSE
    IF (LLFIRST_TIME) THEN
       CALL MPI_SEND(NODENAME,LEN(NODENAME),MPI_BYTE,0,ITAG,KCOMM,ERROR)
       CALL CHECK_ERROR("from MPI_SEND(NODENAME)",__FILE__,__LINE__)
       CALL MPI_SEND(IORANK,1,MPI_INTEGER4,0,ITAG+1,KCOMM,ERROR)
       CALL CHECK_ERROR("from MPI_SEND(IORANK)",__FILE__,__LINE__)
       LLFIRST_TIME = .FALSE.
       CALL CONDBARR()
       CALL CHECK_ERROR("from MPI_BARRIER(NODENAME)",__FILE__,__LINE__)
    ENDIF
    SENDBUF(1)=NODEHUGE
    SENDBUF(2)=MEMFREE
    SENDBUF(3)=CACHED
    SENDBUF(4)=HEAP_SIZE
    SENDBUF(5)=TASKSMALL
    DO K=0,MAXNUMA-1
       SENDBUF(5+2*K+1)=SMALLPAGE(K)
       SENDBUF(5+2*K+2)=HUGEPAGE(K)
    ENDDO
    CALL MPI_SEND(SENDBUF,SIZE(SENDBUF),MPI_INTEGER8,0,ITAG+2,KCOMM,ERROR)
    CALL CHECK_ERROR("from MPI_SEND(SENDBUF)",__FILE__,__LINE__)
ENDIF

IF (.not.LLNOCOMM) THEN
   CALL CONDBARR()
   CALL CHECK_ERROR("from MPI_BARRIER(at end)",__FILE__,__LINE__)
ENDIF

CONTAINS

SUBROUTINE PRT_EMPTY(KUN,KOUNT)
IMPLICIT NONE
INTEGER(KIND=JPIM), INTENT(IN) :: KUN,KOUNT
INTEGER(KIND=JPIM) :: JJ
DO JJ=1,KOUNT
   WRITE(KUN,'(a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO "
ENDDO
END SUBROUTINE PRT_EMPTY

SUBROUTINE PRT_DETAIL(KUN)
IMPLICIT NONE
INTEGER(KIND=JPIM), INTENT(IN) :: KUN
CHARACTER(LEN=128) :: JOBNAME
CHARACTER(LEN=128) :: JOBID
CALL GET_ENVIRONMENT_VARIABLE('EC_JOB_NAME',JOBNAME)
IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBNAME',JOBNAME)
IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_NAME',JOBNAME)
IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBNAME',JOBNAME)
CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBID',JOBID)
IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_ID',JOBID)
IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBID',JOBID)
CALL PRT_EMPTY(KUN,2)
WRITE(KUN,'(3a)',advance='no') CLPFX(1:IPFXLEN)//"## EC_MEMINFO Detailed memory information ", &
     "for program ",TRIM(PROGRAM)
WT = UTIL_WALLTIME() - WT0
WRITE(KUN,'(a,f10.3,a)') " -- wall-time : ",WT,"s" 
WRITE(KUN,'(a,i0,a,i0,a,i0,a,i0,a,i0,a,a,":",a,":",a,a,a,"-",a,"-",a)') &
     CLPFX(1:IPFXLEN)//"## EC_MEMINFO Running on ",NUMNODES," nodes (",NNUMA,&
     "-numa) with ",NPROC-IOTASKS, &
     " compute + ",IOTASKS," I/O-tasks and ", OMP_GET_MAX_THREADS(), " threads at ", &
     CLTIMEOD(1:2),CLTIMEOD(3:4),CLTIMEOD(5:10), &
     " on ",CLDATEOD(7:8),CLMON(IMON),CLDATEOD(1:4)
WRITE(KUN,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO The Job Name is ",TRIM(JOBNAME), &
     " and the Job ID is ",TRIM(JOBID)
CALL PRT_EMPTY(KUN,1)
END SUBROUTINE PRT_DETAIL

SUBROUTINE PRT_HDR(KUN)
IMPLICIT NONE
INTEGER(KIND=JPIM), INTENT(IN) :: KUN
INTEGER(KIND=JPIM) :: INUMA
INUMA = NNUMA
!INUMA = MAXNUMA
!INUMA = 2
WRITE(KUN,'(A)',advance='no') &
     CLPFX(1:IPFXLEN)//"## EC_MEMINFO                   | TC    | MEMORY USED(MB) |"
DO K=0,INUMA-1
   IF (K == 0) THEN
      WRITE(KUN,'(A)',advance='no') " MEMORY FREE(MB)"
   ELSE
      WRITE(KUN,'(A)',advance='no') "  -------------  "
   ENDIF
ENDDO
WRITE(KUN,'(A)') "INCLUDING CACHED |  %USED %HUGE"

WRITE(KUN,'(A)',advance='no') &
     CLPFX(1:IPFXLEN)//"## EC_MEMINFO                   | Malloc| Inc Heap        |"
DO K=0,INUMA-1
   WRITE(KUN,'(A,I1,A)',advance='no') " Numa region ",K,"  |"
ENDDO
WRITE(KUN,'(A)') "                |"

WRITE(KUN,'(A)',advance='no') &
     CLPFX(1:IPFXLEN)//"## EC_MEMINFO Node Name         | Heap  | RSS("//zum//")        |"
DO K=0,INUMA-1
   WRITE(KUN,'(A)',advance='no') " Small  Huge or |"
ENDDO
WRITE(KUN,'(A)') " Total          |"

WRITE(KUN,'(A)',advance='no') &
     CLPFX(1:IPFXLEN)//"## EC_MEMINFO                   | (sum) | Small    Huge   |"
DO K=0,INUMA-1
   WRITE(KUN,'(A)',advance='no') "  Only   Small  |"
ENDDO
WRITE(KUN,'(A)') " Memfree+Cached |"
END SUBROUTINE PRT_HDR

SUBROUTINE PRT_DATA(KUN)
IMPLICIT NONE
INTEGER(KIND=JPIM), INTENT(IN) :: KUN
INTEGER(KIND=JPIM) :: INUMA
INUMA = NNUMA
!INUMA = MAXNUMA
!INUMA = 2
WRITE(KUN,'(a,i4,1x,a,3i8,1x)',advance='no') &
     CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
     NODENUM,LASTNODE,HEAP_SIZE,TASKSMALL,NODEHUGE
DO K=0,INUMA-1
   WRITE(KUN,'(1x,2i8)',advance='no') SMALLPAGE(K),HUGEPAGE(K)
ENDDO
WRITE(KUN,'(2x,2i8,3x,2f6.1,a)') &
     MEMFREE,CACHED, &
     PERCENT_USED,trim(ID_STRING)
END SUBROUTINE PRT_DATA

SUBROUTINE CONDBARR()
IF (KBARR /= 0) CALL MPI_BARRIER(KCOMM,ERROR)
END SUBROUTINE CONDBARR

SUBROUTINE CHECK_ERROR(CLWHAT,SRCFILE,SRCLINE)
IMPLICIT NONE
CHARACTER(LEN=*), INTENT(IN) :: CLWHAT, SRCFILE
INTEGER(KIND=JPIM), INTENT(IN) :: SRCLINE
IF (ERROR /= 0) THEN
   WRITE(0,'(A,I0,1X,A,1X,"(",A,":",I0,")")') &
        & CLPFX(1:IPFXLEN)//"## EC_MEMINFO error code =",ERROR,CLWHAT,SRCFILE,SRCLINE
   CALL MPI_ABORT(KCOMM,-1,ERROR)
ENDIF
ERROR = 0
END SUBROUTINE CHECK_ERROR

SUBROUTINE RNSORT
IMPLICIT NONE
ALLOCATE(IDX(0:NPROC-1))
IOTASKS = 0
K = 0
NODENUM = 0
DO I=0,NPROC-1
   IF (RN(I)%IORANK == 1) THEN
      IOTASKS = IOTASKS + 1
      RN(I)%IORANK = IOTASKS
   ELSE
      RN(I)%IORANK = 0
   ENDIF
   IF (RN(I)%NODENUM == -1) THEN
      NODENUM = NODENUM + 1
      RN(I)%NODENUM = NODENUM
      IDX(K) = I
      K = K + 1
      LASTNODE = RN(I)%NODE
      DO J=I+1,NPROC-1
         IF (RN(J)%NODENUM == -1) THEN
            IF (RN(J)%NODE == LASTNODE) THEN
               RN(J)%NODENUM = NODENUM
               IDX(K) = J
               K = K + 1
            ENDIF
         ENDIF
      ENDDO
   ENDIF
ENDDO
NUMNODES = NODENUM
1000 FORMAT(/1X,4A12,1X,A12,1X,A12)
1001 FORMAT(1X,4I12,1X,A12,1X,I12)
1002 FORMAT(1X,3I12,A12,1X,A12,1X,I12)
WRITE(6,1000) "#","NODE#","RANK#","I/O-TASK#","NODENAME","IDX"
DO I=0,NPROC-1
   IF (RN(I)%IORANK > 0) THEN
      WRITE(6,1001) I,RN(I)%NODENUM,RN(I)%RANK,RN(I)%IORANK,RN(I)%NODE,IDX(I)
   ELSE
      WRITE(6,1002) I,RN(I)%NODENUM,RN(I)%RANK,"No",RN(I)%NODE,IDX(I)
   ENDIF
ENDDO
WRITE(6,*)
CALL FLUSH(6)
END SUBROUTINE RNSORT

END SUBROUTINE EC_MEMINFO

SUBROUTINE MEMINFO(KOUT,KSTEP)
USE PARKIND1, ONLY : JPIM, JPIB
IMPLICIT NONE
INTEGER(KIND=JPIM), INTENT(IN) :: KOUT, KSTEP
CHARACTER(LEN=32) CLSTEP
CHARACTER(LEN=160) :: LINE
CHARACTER(LEN=12) :: NODENAME
INTEGER(KIND=JPIB) :: NODE(0:17), ISMALL, IHUGE, ITOTAL
INTEGER(KIND=JPIM) :: I,INUMA,ICOMM
#include "ec_meminfo.intfb.h"
WRITE(CLSTEP,'(11X,"STEP",I5," :")') KSTEP
ICOMM = -2 ! No headers from EC_MEMINFO by default
IF (KSTEP == 0) ICOMM = -1 ! Do print headers, too
CALL EC_MEMINFO(KOUT,TRIM(CLSTEP),ICOMM,0,0)
CALL FLUSH(KOUT)
RETURN ! For now
#if 0
CALL EC_GETHOSTNAME(NODENAME) ! from support/env.c
OPEN(FILE="/proc/buddyinfo",UNIT=502,ERR=98)
READ(502,'(a)') LINE
READ(502,'(a)') LINE
DO INUMA=0,1
   NODE(:)=0
   READ(502,'(a)',END=99) LINE
   READ(LINE(22:160),*,ERR=99,END=99) NODE
   ISMALL = 0
   DO I=0,8
      ISMALL = ISMALL + NODE(I) * (2**I)
   ENDDO
   ! Pages >= 2M
   IHUGE = 0
   DO I=9,SIZE(NODE)-1
      IHUGE = IHUGE + NODE(I) * (2**I)
   ENDDO
   ITOTAL = ISMALL + IHUGE
   ISMALL = (ISMALL * 4096)/ONEMEGA
   IHUGE = (IHUGE * 4096)/ONEMEGA
   ITOTAL = (ITOTAL * 4096)/ONEMEGA
   WRITE(KOUT,'("   MEMINFO: STEP=",I0," ",A," NUMA# ",I0," : Free Total = SMALL + HUGEPAGES in MB: ",I0," = ",I0," + ",I0)') &
        & KSTEP, NODENAME, INUMA, ITOTAL, ISMALL, IHUGE
   WRITE(KOUT,'(" BUDDYINFO: STEP=",I0," ",A," NUMA# ",I0," : Count of free 2^(0..",I0,")*4096B blocks: ",A)') &
        & KSTEP, NODENAME, INUMA, SIZE(NODE)-1, LINE(22:160)
ENDDO
99 CONTINUE
CLOSE(502)
98 CONTINUE
CALL FLUSH(KOUT)
#endif
END SUBROUTINE MEMINFO

SUBROUTINE EC_MPI_FINALIZE(KERROR,LDCALLFINITO)
USE PARKIND1, ONLY : JPIM
USE MPL_MPIF
IMPLICIT NONE
INTEGER(KIND=JPIM), INTENT(OUT) :: KERROR
LOGICAL, INTENT(IN) :: LDCALLFINITO
INTEGER(KIND=JPIM) :: IBARR
#include "ec_meminfo.intfb.h"
!integer :: me, ierr
!call mpi_comm_rank(MPI_COMM_WORLD,me,ierr)
!write(6,*) me,': EC_MPI_FINALIZE: LDCALLFINITO=',LDCALLFINITO
!call flush(6)
!if (me == 0) CALL LINUX_TRBK()
IF (LDCALLFINITO) THEN !*** common MPI_Finalize()
   IBARR = 1
!   write(6,*) me,': Now calling EC_MEMINFO for the last time with ibarr=',ibarr
!   call flush(6)
   CALL EC_MEMINFO(-1,"ec_mpi_finalize",MPI_COMM_WORLD,IBARR,0)
   CALL MPI_FINALIZE(KERROR)
ELSE
   KERROR = 0
ENDIF
END SUBROUTINE EC_MPI_FINALIZE

SUBROUTINE EC_PMON(KCASE,ENERGY,POWER,KERROR)
USE PARKIND1, ONLY : JPIM, JPIB
IMPLICIT NONE
INTEGER(KIND=JPIM),INTENT(IN) :: KCASE
INTEGER(KIND=JPIB),INTENT(OUT) :: ENERGY,POWER
INTEGER(KIND=JPIM),INTENT(OUT) :: KERROR
INTEGER(KIND=JPIM),SAVE :: MONINIT = 0
INTEGER(KIND=JPIM) :: ISTAT
INTEGER(KIND=JPIB),SAVE :: ENERGY_START = 0
IF (MONINIT == 0) THEN
   ! The very first time
   OPEN(503,FILE='/sys/cray/pm_counters/energy',ERR=99,STAT=ISTAT)
   READ(503,*,ERR=99,STAT=ISTAT) ENERGY_STAT
   CLOSE(503)
   MONINIT = 1 ! Ok
   GOTO 100
99 CONTINUE
   MONINIT = -1 ! Never try again
100 CONTINUE
ENDIF
ENERGY = 0
POWER = 0
IF (MONINIT > 0) THEN
ENDIF
END SUBROUTINE EC_PMON
