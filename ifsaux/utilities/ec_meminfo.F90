SUBROUTINE EC_MEMINFO(KU,CDSTRING,KCOMM,KBARR)

IMPLICIT NONE

!-- EC_MEMINFO:
!   Author   : Peter Towers (ECMWF)  : 2015-2016
!   Modified : Sami Saarinen (ECMWF) : 21-SEP-2016 : Added getenv EC_MEMINFO -- export EC_MEMINFO=0 disables any EC_MEMINFO output

#include "mpif.h"

INTEGER(KIND=4), INTENT(IN) :: KCOMM,KBARR
INTEGER(KIND=4), INTENT(IN) :: KU
CHARACTER*(*), INTENT(IN) :: CDSTRING
INTEGER(KIND = 4) :: ID,KULOUT
INTEGER(KIND=4) :: II,I,J,K,MYPROC,NPROC,LEN,ERROR,ITAG,NODENUM
INTEGER(KIND=8) :: TASKSMALL,NODEHUGE,MEMFREE,CACHED,NFREE
INTEGER(KIND=8),SAVE :: NODEHUGE_CACHED
INTEGER(KIND=8) :: SMALLPAGE0,SMALLPAGE1,HUGEPAGE0,HUGEPAGE1
INTEGER(KIND=8) :: SENDBUF(9),RECVBUF(9)
INTEGER(KIND=8) :: GETHWM,GETRSS
INTEGER(KIND=8) :: HEAP_SIZE
INTEGER(KIND=4),SAVE :: PAGESIZE = 0
INTEGER(KIND=4) :: N18
INTEGER(KIND=4) :: NODE0(18),NODE1(18)
INTEGER(KIND=8) :: BUCKET0(18),BUCKET1(18)
REAL(KIND=4) :: PERCENT_USED(2)
CHARACTER(LEN=512) :: TMPDIR
CHARACTER(LEN=512) :: PROGRAM
CHARACTER(LEN=12)  :: NODENAME,LASTNODE
CHARACTER(LEN=12)  :: VAL
CHARACTER(LEN=1)  :: M
CHARACTER(LEN=160) ::LINE
CHARACTER(LEN=56) :: FILENAME
CHARACTER(LEN=128) :: JOBNAME
CHARACTER(LEN=128) :: JOBID
CHARACTER(LEN=2) :: CLEC_MEMINFO
CHARACTER(LEN=4) :: CSTAR
CHARACTER(LEN=LEN(CSTAR)+1+LEN(CDSTRING)) :: ID_STRING
CHARACTER (LEN = 10) ::  CLDATEOD,CLTIMEOD,CLZONEOD
CHARACTER(LEN=3), PARAMETER :: CLMON(1:12) = (/ &
     'Jan','Feb','Mar','Apr','May','Jun', &
     'Jul','Aug','Sep','Oct','Nov','Dec' /)
INTEGER(KIND=4) :: IVALUES(8), IMON
INTEGER(KIND=4) :: IRECV_STATUS(MPI_STATUS_SIZE)
LOGICAL :: LLNOCOMM, LLNOHDR
LOGICAL, SAVE :: LLFIRST_TIME = .TRUE.
TYPE RANKNODE_T
   INTEGER(KIND=4) :: NODENUM
   INTEGER(KIND=4) :: RANK
   INTEGER(KIND=4) :: IORANK
   CHARACTER(LEN=LEN(NODENAME)) :: NODE
END TYPE
TYPE (RANKNODE_T), ALLOCATABLE, SAVE :: RN(:)
INTEGER(KIND=4), ALLOCATABLE, SAVE :: IDX(:)
INTEGER(KIND=4), SAVE :: NUMNODES = 0
INTEGER(KIND=4), SAVE :: IOTASKS = 0
INTEGER(KIND=4) :: IORANK
REAL(KIND=8), EXTERNAL :: UTIL_WALLTIME
REAL(KIND=8), SAVE :: WT0
REAL(KIND=8) :: WT
CHARACTER(LEN=64) :: CLPFX
CHARACTER(LEN=3) :: ZUM
INTEGER(KIND=4) :: IPFXLEN
INTEGER OMP_GET_MAX_THREADS
#ifdef _OPENMP
EXTERNAL OMP_GET_MAX_THREADS
#else
OMP_GET_MAX_THREADS() = 1
#endif

CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO',CLEC_MEMINFO)
IF (CLEC_MEMINFO == '0') RETURN

LLNOCOMM = (KCOMM == -1 .or. KCOMM == -2)
LLNOHDR = (KCOMM == -2)

CALL FLUSH(0)

IF (LLNOCOMM) THEN
   ! Direct call to obtain EC_meminfo -output
   ERROR = 0
   MYPROC = 0
   NPROC = 1
   CLPFX = CDSTRING
   IPFXLEN = LEN_TRIM(CLPFX)
   ZUM = 'tsk'
ELSE
   CLPFX = ' '
   IPFXLEN = 0
   ZUM = 'sum'
   CALL CONDBARR()
   CALL CHECK_ERROR("from MPI_BARRIER(at start)",__FILE__,__LINE__)
   
   CALL MPI_COMM_RANK(KCOMM,MYPROC,ERROR)
   CALL CHECK_ERROR("from MPI_COMM_RANK",__FILE__,__LINE__)

   CALL MPI_COMM_SIZE(KCOMM,NPROC,ERROR)
   CALL CHECK_ERROR("from MPI_COMM_SIZE",__FILE__,__LINE__)
ENDIF

IF (MYPROC == 0) THEN 
  IF (PAGESIZE == 0) WT0 = UTIL_WALLTIME()
  CALL GETARG(0,PROGRAM)
!
! Use already open file for output or $EC_MEMINFO_TMPDIR/meminfo
! We do not use $TMPDIR as it may have been inherited from mother superiour (MOMS) node
!
  IF(KU == -1) THEN
    CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_TMPDIR',TMPDIR)
    IF (TMPDIR == ' ') TMPDIR = '.'
!    write(0,*) '## EC_MEMINFO: KCOMM=',KCOMM
!    CALL LINUX_TRBK()
    KULOUT=501
    OPEN(UNIT=KULOUT,FILE=TRIM(TMPDIR)//"/"//"meminfo",STATUS='unknown', &
         ACTION='write',POSITION='append')
  ELSE
    KULOUT=KU
  ENDIF

  CALL DATE_AND_TIME(CLDATEOD,CLTIMEOD,CLZONEOD,IVALUES)
  READ(CLDATEOD(5:6),'(I2)') IMON
  CALL GET_ENVIRONMENT_VARIABLE('EC_JOB_NAME',JOBNAME)
  IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBNAME',JOBNAME)
  IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_NAME',JOBNAME)
  IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBNAME',JOBNAME)
  CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBID',JOBID)
  IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_ID',JOBID)
  IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBID',JOBID)

  IF (.not.LLNOCOMM) THEN
     WRITE(KULOUT,'(a,/,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",CLPFX(1:IPFXLEN)//"## EC_MEMINFO"
     WRITE(KULOUT,'(3a)',advance='no') CLPFX(1:IPFXLEN)//"## EC_MEMINFO Detailed memory information ", &
          "for program ",TRIM(PROGRAM)
     IF (NUMNODES > 0) THEN
        WT = UTIL_WALLTIME() - WT0
        WRITE(KULOUT,'(a,i0,a,f10.3,a)') " on ",NUMNODES," nodes -- time: ",WT,"s" 
     ELSE
        WRITE(KULOUT,'(1x)')
     ENDIF
     WRITE(KULOUT,'(a,i0,a,i0,a,i0,a,a,":",a,":",a,a,a,"-",a,"-",a)') &
          CLPFX(1:IPFXLEN)//"## EC_MEMINFO Running with ",NPROC-IOTASKS, &
          " computational + ",IOTASKS," I/O-tasks and ", OMP_GET_MAX_THREADS(), " threads at ", &
          CLTIMEOD(1:2),CLTIMEOD(3:4),CLTIMEOD(5:10), &
          " on ",CLDATEOD(7:8),CLMON(IMON),CLDATEOD(1:4)
     WRITE(KULOUT,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO The Job Name is ",TRIM(JOBNAME), &
          " and the Job ID is ",TRIM(JOBID)
     WRITE(KULOUT,'(a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO "
  ENDIF
  IF (.not.LLNOHDR) THEN
     WRITE(KULOUT,'(3a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                       "                  | TC    | MEMORY USED(MB) |", &
                       "          MEMORY FREE(MB)        INCLUDING CACHED |  %USED %HUGE"
     WRITE(KULOUT,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                       "                  | Malloc| Inc Heap        |", &
                       " Numa node 0    | Numa node 1    |                |"
     WRITE(KULOUT,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                       "Node Name         | Heap  | RSS("//zum//")        |", &
                       " Small  Huge or | Small  Huge or | Total          |" 
     WRITE(KULOUT,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                       "                  | ("//zum//") | Small    Huge   |", &
                       "  Only   Small  |  Only   Small  | Memfree+Cached |"
  ENDIF
  IF(KU == -1) THEN
    WRITE(0,'(a,/,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",CLPFX(1:IPFXLEN)//"## EC_MEMINFO"
    WRITE(0,'(3a)',advance='no') CLPFX(1:IPFXLEN)//"## EC_MEMINFO Detailed memory information ", &
         "for program ",TRIM(PROGRAM)
    IF (NUMNODES > 0) THEN
       WT = UTIL_WALLTIME() - WT0
       WRITE(0,'(a,i0,a,f10.3,a)') " on ",NUMNODES," nodes -- time: ",WT,"s" 
    ELSE
       WRITE(0,'(1x)')
    ENDIF
    WRITE(0,'(a,i0,a,i0,a,i0,a,a,":",a,":",a,a,a,"-",a,"-",a)') &
         CLPFX(1:IPFXLEN)//"## EC_MEMINFO Running with ",NPROC-IOTASKS, &
         " computational + ",IOTASKS," I/O-tasks and ", OMP_GET_MAX_THREADS(), " threads at ", &
         CLTIMEOD(1:2),CLTIMEOD(3:4),CLTIMEOD(5:10), &
         " on ",CLDATEOD(7:8),CLMON(IMON),CLDATEOD(1:4)
    WRITE(0,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO The Job Name is ",TRIM(JOBNAME), &
                    " and the Job ID is ",TRIM(JOBID)
    WRITE(0,'(a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO "
    WRITE(0,'(3a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                    "                  | TC    | MEMORY USED(MB) |", &
                    "          MEMORY FREE(MB)        INCLUDING CACHED |  %USED %HUGE"
    WRITE(0,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                    "                  | Malloc| Inc Heap        |", &
                    " Numa node 0    | Numa node 1    |                |"
    WRITE(0,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                    "Node Name         | Heap  | RSS("//zum//")        |", &
                    " Small  Huge or | Small  Huge or | Total          |" 
    WRITE(0,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
                    "                  | ("//zum//") | Small    Huge   |", &
                    "  Only   Small  |  Only   Small  | Memfree+Cached |" 
  ENDIF
ENDIF

CALL EC_GETHOSTNAME(NODENAME) ! from support/env.c

IF (PAGESIZE == 0) THEN ! First time
   PAGESIZE=2048
   CALL GET_ENVIRONMENT_VARIABLE("HUGETLB_DEFAULT_PAGE_SIZE",VAL)
   I=INDEX(VAL,"M")
   IF(I > 0) THEN
      READ(VAL(1:I-1),*) PAGESIZE
      PAGESIZE=PAGESIZE*1024
   ENDIF

   NODEHUGE=0
   
   WRITE(FILENAME,'(a,i0,a)') "/sys/kernel/mm/hugepages/hugepages-", &
        PAGESIZE,"kB/nr_hugepages"

   IF(PAGESIZE > 0) THEN
      OPEN(502,FILE=FILENAME,STATUS="old")
      READ(502,*) NODEHUGE
      CLOSE(502)
   ENDIF

   NODEHUGE=NODEHUGE*PAGESIZE
   NODEHUGE=NODEHUGE/1024
   NODEHUGE_CACHED = NODEHUGE
ENDIF

NODEHUGE=NODEHUGE_CACHED

IF (NODEHUGE > 0) THEN
   CSTAR = " H/p"
ELSE
   CSTAR = " s/p"
ENDIF
   
MEMFREE = 0
CACHED = 0
      
OPEN(FILE="/proc/meminfo",UNIT=502)
DO I=1,10
  READ(502,'(a)') LINE
  IF(LINE(1:7) == "MemFree") THEN
    READ(LINE(9:80),*) MEMFREE 
  ELSEIF(LINE(1:6) == "Cached") THEN
    READ(LINE(8:80),*) CACHED
  ENDIF
ENDDO
CLOSE(502)

MEMFREE=MEMFREE/1024
CACHED=CACHED/1024

TASKSMALL=GETRSS()/(1024*1024)

OPEN(FILE="/proc/buddyinfo",UNIT=502)

READ(502,'(a)') LINE
READ(502,'(a)') LINE
READ(502,'(a)') LINE
NODE0(:)=-1
N18=0
READ(LINE(22:),*,END=98) NODE0
98 CONTINUE
N18 = COUNT(NODE0 >= 0)
NODE1(:)=0
READ(502,'(a)',END=99) LINE
READ(LINE(22:),*) NODE1(1:N18)

99 CONTINUE
CLOSE(502)

BUCKET0(:) = 0
BUCKET1(:) = 0
BUCKET0(1)=NODE0(1)*4096
BUCKET1(1)=NODE1(1)*4096
DO I=2,N18
  BUCKET0(I)=NODE0(I)*4096
  BUCKET1(I)=NODE1(I)*4096
  DO J=2,I
    BUCKET0(I)=BUCKET0(I)*2
    BUCKET1(I)=BUCKET1(I)*2
  ENDDO
ENDDO

SMALLPAGE0=0
SMALLPAGE1=0
DO I=1,9
   SMALLPAGE0=SMALLPAGE0+BUCKET0(I)
   SMALLPAGE1=SMALLPAGE1+BUCKET1(I)
ENDDO
HUGEPAGE0=0
HUGEPAGE1=0
DO I=10,N18
   HUGEPAGE0=HUGEPAGE0+BUCKET0(I)
   HUGEPAGE1=HUGEPAGE1+BUCKET1(I)
ENDDO

SMALLPAGE0=SMALLPAGE0/(1024*1024)
SMALLPAGE1=SMALLPAGE1/(1024*1024)
HUGEPAGE0=HUGEPAGE0/(1024*1024)
HUGEPAGE1=HUGEPAGE1/(1024*1024)

HEAP_SIZE=GETHWM()/(1024*1024)

ITAG = 98765

IF (NPROC > 1 .and. LLFIRST_TIME) THEN
   IORANK = 0
   IF (LEN(CDSTRING) >= 2) THEN
      IF (CDSTRING(1:2) == 'io' .or. CDSTRING(1:2) == 'IO') IORANK = 1
   ENDIF
   IF (MYPROC == 0) THEN
      ALLOCATE(RN(0:NPROC-1))
      LASTNODE=NODENAME
      DO I=0,NPROC-1
         RN(I)%NODENUM = -1
         IF (I > 0) THEN ! Receive in MPI-rank order
            CALL MPI_RECV(LASTNODE,LEN(LASTNODE),MPI_BYTE,I,ITAG,KCOMM,IRECV_STATUS,ERROR)
            CALL CHECK_ERROR("from MPI_RECV(LASTNODE)",__FILE__,__LINE__)
            CALL MPI_RECV(IORANK,1,MPI_INTEGER4,I,ITAG+1,KCOMM,IRECV_STATUS,ERROR)
            CALL CHECK_ERROR("from MPI_RECV(IORANK)",__FILE__,__LINE__)
            RN(I)%RANK = I
         ELSE
            RN(I)%RANK = 0 ! Itself
         ENDIF
         RN(I)%IORANK = IORANK
         RN(I)%NODE = LASTNODE
      ENDDO
      CALL RNSORT
      LLFIRST_TIME = .FALSE.
      CALL CONDBARR()
      CALL CHECK_ERROR("from MPI_BARRIER(LASTNODE)",__FILE__,__LINE__)
   ENDIF
ENDIF

IF (MYPROC == 0) THEN
    NODENUM=1
    LASTNODE = NODENAME
    DO II=1,NPROC-1
        K = IDX(II)
        I = RN(K)%RANK
        CALL MPI_RECV(RECVBUF(1:9),9,MPI_INTEGER8,I,ITAG+2,KCOMM,IRECV_STATUS,ERROR)
        CALL CHECK_ERROR("from MPI_RECV(RECVBUF)",__FILE__,__LINE__)
        NODENAME = RN(K)%NODE
        IF(LASTNODE==NODENAME)THEN
          HEAP_SIZE=HEAP_SIZE+RECVBUF(8)
          TASKSMALL=TASKSMALL+RECVBUF(9)
        ELSE
          PERCENT_USED(2) = 0
          IF(HEAP_SIZE >= NODEHUGE) THEN
! running with small pages
            PERCENT_USED(1)=100.0*(TASKSMALL+NODEHUGE)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
          ELSE
! running with huge pages
            PERCENT_USED(1)=100.0*(HEAP_SIZE+TASKSMALL)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
            IF (NODEHUGE > 0) THEN
               NFREE = HUGEPAGE0 + HUGEPAGE1
               PERCENT_USED(2) = (100.0*(NODEHUGE - NFREE))/NODEHUGE
               IF (PERCENT_USED(2) < 0) PERCENT_USED(2) = 0
               IF (PERCENT_USED(2) > 100) PERCENT_USED(2) = 100
            ENDIF
          ENDIF
          IF (.not.LLNOCOMM) THEN
             ID_STRING = CSTAR//":"//CDSTRING
          ELSE
             ID_STRING = CSTAR
          ENDIF
          WRITE(KULOUT,'(a,i4,1x,a,3i8,2x,2i8,1x,2i8,2x,2i8,3x,2f6.1,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
 &                      NODENUM,LASTNODE,HEAP_SIZE,TASKSMALL,NODEHUGE,   &
 &                      SMALLPAGE0,HUGEPAGE0,SMALLPAGE1,HUGEPAGE1,MEMFREE,CACHED, &
 &                      PERCENT_USED,trim(ID_STRING)
          IF(KU == -1) THEN
            WRITE(0,'(a,i4,1x,a,3i8,2x,2i8,1x,2i8,2x,2i8,3x,2f6.1,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
 &                   NODENUM,LASTNODE,HEAP_SIZE,TASKSMALL,NODEHUGE,   &
 &                   SMALLPAGE0,HUGEPAGE0,SMALLPAGE1,HUGEPAGE1,MEMFREE,CACHED, &
 &                   PERCENT_USED,trim(ID_STRING)
          ENDIF

          NODEHUGE=RECVBUF(1)
          MEMFREE=RECVBUF(2)
          CACHED=RECVBUF(3)
          SMALLPAGE0=RECVBUF(4)
          SMALLPAGE1=RECVBUF(5)
          HUGEPAGE0=RECVBUF(6)
          HUGEPAGE1=RECVBUF(7)
          HEAP_SIZE=RECVBUF(8)
          TASKSMALL=RECVBUF(9)
          NODENUM=NODENUM+1
          LASTNODE=NODENAME
        ENDIF
    ENDDO
    PERCENT_USED(2) = 0
    IF(HEAP_SIZE >= NODEHUGE) THEN
! running with small pages
      PERCENT_USED(1)=100.0*(TASKSMALL+NODEHUGE)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
    ELSE
! running with huge pages
      PERCENT_USED(1)=100.0*(HEAP_SIZE+TASKSMALL)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
      IF (NODEHUGE > 0) THEN
         NFREE = HUGEPAGE0 + HUGEPAGE1
         PERCENT_USED(2) = (100.0*(NODEHUGE - NFREE))/NODEHUGE
         IF (PERCENT_USED(2) < 0) PERCENT_USED(2) = 0
         IF (PERCENT_USED(2) > 100) PERCENT_USED(2) = 100
      ENDIF
    ENDIF
    IF (.not.LLNOCOMM) THEN
       ID_STRING = CSTAR//":"//CDSTRING
    ELSE
       ID_STRING = CSTAR
    ENDIF
    WRITE(KULOUT,'(a,i4,1x,a,3i8,2x,2i8,1x,2i8,2x,2i8,3x,2f6.1,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
 &                NODENUM,LASTNODE,HEAP_SIZE,TASKSMALL,NODEHUGE,   &
 &                SMALLPAGE0,HUGEPAGE0,SMALLPAGE1,HUGEPAGE1,MEMFREE,CACHED, &
 &                PERCENT_USED,trim(ID_STRING)

    IF(KU == -1) THEN
      WRITE(0,'(a,i4,1x,a,3i8,2x,2i8,1x,2i8,2x,2i8,3x,2f6.1,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
 &                  NODENUM,LASTNODE,HEAP_SIZE,TASKSMALL,NODEHUGE,   &
 &                  SMALLPAGE0,HUGEPAGE0,SMALLPAGE1,HUGEPAGE1,MEMFREE,CACHED, &
 &                  PERCENT_USED,trim(ID_STRING)
      CLOSE(KULOUT)
    ENDIF
ELSE
    IF (LLFIRST_TIME) THEN
       CALL MPI_SEND(NODENAME,LEN(NODENAME),MPI_BYTE,0,ITAG,KCOMM,ERROR)
       CALL CHECK_ERROR("from MPI_SEND(NODENAME)",__FILE__,__LINE__)
       CALL MPI_SEND(IORANK,1,MPI_INTEGER4,0,ITAG+1,KCOMM,ERROR)
       CALL CHECK_ERROR("from MPI_SEND(IORANK)",__FILE__,__LINE__)
       LLFIRST_TIME = .FALSE.
       CALL CONDBARR()
       CALL CHECK_ERROR("from MPI_BARRIER(NODENAME)",__FILE__,__LINE__)
    ENDIF
    SENDBUF(1)=NODEHUGE
    SENDBUF(2)=MEMFREE
    SENDBUF(3)=CACHED
    SENDBUF(4)=SMALLPAGE0
    SENDBUF(5)=SMALLPAGE1
    SENDBUF(6)=HUGEPAGE0
    SENDBUF(7)=HUGEPAGE1
    SENDBUF(8)=HEAP_SIZE
    SENDBUF(9)=TASKSMALL
    CALL MPI_SEND(SENDBUF(1:9),9,MPI_INTEGER8,0,ITAG+2,KCOMM,ERROR)
    CALL CHECK_ERROR("from MPI_SEND(SENDBUF)",__FILE__,__LINE__)
ENDIF

IF (.not.LLNOCOMM) THEN
   CALL CONDBARR()
   CALL CHECK_ERROR("from MPI_BARRIER(at end)",__FILE__,__LINE__)
ENDIF

CONTAINS

SUBROUTINE CONDBARR()
IF (KBARR /= 0) CALL MPI_BARRIER(KCOMM,ERROR)
END SUBROUTINE CONDBARR

SUBROUTINE CHECK_ERROR(CLWHAT,SRCFILE,SRCLINE)
IMPLICIT NONE
CHARACTER(LEN=*), INTENT(IN) :: CLWHAT, SRCFILE
INTEGER(KIND=4), INTENT(IN) :: SRCLINE
IF (ERROR /= 0) THEN
   WRITE(0,'(A,I0,1X,A,1X,"(",A,":",I0,")")') &
        & CLPFX(1:IPFXLEN)//"## EC_MEMINFO error code =",ERROR,CLWHAT,SRCFILE,SRCLINE
   CALL MPI_ABORT(KCOMM,-1,ERROR)
ENDIF
ERROR = 0
END SUBROUTINE CHECK_ERROR

SUBROUTINE RNSORT
IMPLICIT NONE
ALLOCATE(IDX(0:NPROC-1))
IOTASKS = 0
K = 0
NODENUM = 0
DO I=0,NPROC-1
   IF (RN(I)%IORANK == 1) THEN
      IOTASKS = IOTASKS + 1
      RN(I)%IORANK = IOTASKS
   ELSE
      RN(I)%IORANK = 0
   ENDIF
   IF (RN(I)%NODENUM == -1) THEN
      NODENUM = NODENUM + 1
      RN(I)%NODENUM = NODENUM
      IDX(K) = I
      K = K + 1
      LASTNODE = RN(I)%NODE
      DO J=I+1,NPROC-1
         IF (RN(J)%NODENUM == -1) THEN
            IF (RN(J)%NODE == LASTNODE) THEN
               RN(J)%NODENUM = NODENUM
               IDX(K) = J
               K = K + 1
            ENDIF
         ENDIF
      ENDDO
   ENDIF
ENDDO
NUMNODES = NODENUM
1000 FORMAT(/1X,4A12,1X,A12,1X,A12)
1001 FORMAT(1X,4I12,1X,A12,1X,I12)
1002 FORMAT(1X,3I12,A12,1X,A12,1X,I12)
WRITE(6,1000) "#","NODE#","RANK#","I/O-TASK#","NODENAME","IDX"
DO I=0,NPROC-1
   IF (RN(I)%IORANK > 0) THEN
      WRITE(6,1001) I,RN(I)%NODENUM,RN(I)%RANK,RN(I)%IORANK,RN(I)%NODE,IDX(I)
   ELSE
      WRITE(6,1002) I,RN(I)%NODENUM,RN(I)%RANK,"No",RN(I)%NODE,IDX(I)
   ENDIF
ENDDO
CALL FLUSH(6)
END SUBROUTINE RNSORT

END SUBROUTINE EC_MEMINFO

SUBROUTINE MEMINFO(KOUT,KSTEP)
IMPLICIT NONE
INTEGER(KIND=4), INTENT(IN) :: KOUT, KSTEP
CHARACTER(LEN=32) CLSTEP
CHARACTER(LEN=160) :: LINE
CHARACTER(LEN=12) :: NODENAME
INTEGER(KIND=8) :: NODE(0:17), ISMALL, IHUGE, ITOTAL
INTEGER(KIND=4) :: I,INUMA,ICOMM
WRITE(CLSTEP,'(11X,"STEP",I5," :")') KSTEP
ICOMM = -2 ! No headers from EC_MEMINFO by default
IF (KSTEP == 0) ICOMM = -1 ! Do print headers, too
CALL EC_MEMINFO(KOUT,TRIM(CLSTEP),ICOMM,0)
CALL FLUSH(KOUT)
RETURN ! For now
CALL EC_GETHOSTNAME(NODENAME) ! from support/env.c
OPEN(FILE="/proc/buddyinfo",UNIT=502,ERR=98)
READ(502,'(a)') LINE
READ(502,'(a)') LINE
DO INUMA=0,1
   NODE(:)=0
   READ(502,'(a)',END=99) LINE
   READ(LINE(22:160),*,ERR=99,END=99) NODE
   ISMALL = 0
   DO I=0,8
      ISMALL = ISMALL + NODE(I) * (2**I)
   ENDDO
   ! Pages >= 2M
   IHUGE = 0
   DO I=9,SIZE(NODE)-1
      IHUGE = IHUGE + NODE(I) * (2**I)
   ENDDO
   ITOTAL = ISMALL + IHUGE
   ISMALL = (ISMALL * 4096)/(1024*1024)
   IHUGE = (IHUGE * 4096)/(1024*1024)
   ITOTAL = (ITOTAL * 4096)/(1024*1024)
   WRITE(KOUT,'("   MEMINFO: STEP=",I0," ",A," NUMA# ",I0," : Free Total = SMALL + HUGEPAGES in MB: ",I0," = ",I0," + ",I0)') &
        & KSTEP, NODENAME, INUMA, ITOTAL, ISMALL, IHUGE
   WRITE(KOUT,'(" BUDDYINFO: STEP=",I0," ",A," NUMA# ",I0," : Count of free 2^(0..",I0,")*4096B blocks: ",A)') &
        & KSTEP, NODENAME, INUMA, SIZE(NODE)-1, LINE(22:160)
ENDDO
99 CONTINUE
CLOSE(502)
98 CONTINUE
CALL FLUSH(KOUT)
END SUBROUTINE MEMINFO
