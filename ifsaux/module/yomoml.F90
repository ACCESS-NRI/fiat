MODULE YOMOML


#include "tsmbkind.h"

IMPLICIT NONE

SAVE

PRIVATE

PUBLIC OML_WAIT_EVENT, OML_SET_EVENT, OML_INCR_EVENT, &
   &   OML_MY_THREAD,  OML_MAX_THREADS , OML_OMP, &
   &   OML_IN_PARALLEL

INTEGER_M :: M_OML_LOCK

CONTAINS

FUNCTION OML_OMP()
LOGICAL :: OML_OMP
OML_OMP=.FALSE.
!$ OML_OMP=.TRUE.
END FUNCTION OML_OMP

FUNCTION OML_IN_PARALLEL()
LOGICAL :: OML_IN_PARALLEL
LOGICAL :: OMP_IN_PARALLEL
OML_IN_PARALLEL=.FALSE.
!$ OML_IN_PARALLEL=OMP_IN_PARALLEL()
END FUNCTION OML_IN_PARALLEL

SUBROUTINE OML_WAIT_EVENT(K,MYLOCK)
INTEGER_M :: K
INTEGER_M,OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  DO
    IF(K.EQ.MYLOCK)EXIT
  ENDDO
ELSE
  DO
    IF(K.EQ.M_OML_LOCK)EXIT
  ENDDO
ENDIF
END SUBROUTINE OML_WAIT_EVENT

SUBROUTINE OML_SET_EVENT(K,MYLOCK)
INTEGER_M :: K
INTEGER_M,OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=K
ELSE
  M_OML_LOCK=K
ENDIF
END SUBROUTINE OML_SET_EVENT

SUBROUTINE OML_INCR_EVENT(K,MYLOCK)
INTEGER_M :: K
INTEGER_M,OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=MYLOCK+K
ELSE
  M_OML_LOCK=M_OML_LOCK+K
ENDIF
END SUBROUTINE OML_INCR_EVENT

FUNCTION OML_MY_THREAD()
INTEGER_M :: OML_MY_THREAD
INTEGER_M OMP_GET_THREAD_NUM
OML_MY_THREAD = 1
!$ OML_MY_THREAD = OMP_GET_THREAD_NUM()+1
END FUNCTION OML_MY_THREAD

FUNCTION OML_MAX_THREADS()
INTEGER_M :: OML_MAX_THREADS
INTEGER_M OMP_GET_MAX_THREADS
OML_MAX_THREADS = 1
!$ OML_MAX_THREADS = OMP_GET_MAX_THREADS()
END FUNCTION OML_MAX_THREADS

END MODULE YOMOML
