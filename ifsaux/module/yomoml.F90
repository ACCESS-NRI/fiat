MODULE YOMOML


#include "tsmbkind.h"

IMPLICIT NONE

SAVE

PRIVATE

PUBLIC OML_WAIT_EVENT, OML_SET_EVENT, OML_INCR_EVENT, &
   &   OML_MY_THREAD,  OML_MAX_THREADS , OML_OMP, &
   &   OML_IN_PARALLEL, &
   &   OML_UNSET_LOCK, OML_INIT_LOCK, OML_SET_LOCK, OML_DESTROY_LOCK

INTEGER_M :: M_LOCK
INTEGER_M :: M_OML_LOCK
INTEGER_M :: M_OML_MAX_THREADS = -1


CONTAINS

FUNCTION OML_OMP()
LOGICAL :: OML_OMP
OML_OMP=.FALSE.
!$ OML_OMP=.TRUE.
END FUNCTION OML_OMP

FUNCTION OML_IN_PARALLEL()
LOGICAL :: OML_IN_PARALLEL
LOGICAL :: OMP_IN_PARALLEL
OML_IN_PARALLEL=.FALSE.
!$ OML_IN_PARALLEL=((OML_MAX_THREADS() > 1).AND.OMP_IN_PARALLEL())
END FUNCTION OML_IN_PARALLEL

SUBROUTINE OML_UNSET_LOCK(MYLOCK)
INTEGER_M,optional :: MYLOCK
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_UNSET_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_UNSET_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
END SUBROUTINE OML_UNSET_LOCK

SUBROUTINE OML_SET_LOCK(MYLOCK)
INTEGER_M,optional :: MYLOCK
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_SET_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_SET_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
END SUBROUTINE OML_SET_LOCK

SUBROUTINE OML_INIT_LOCK(MYLOCK)
INTEGER_M,optional :: MYLOCK
!$ IF(PRESENT(MYLOCK))THEN
!$     CALL OMP_INIT_LOCK(MYLOCK)
!$ ELSE
!$     CALL OMP_INIT_LOCK(M_LOCK)
!$ ENDIF
END SUBROUTINE OML_INIT_LOCK

SUBROUTINE OML_DESTROY_LOCK(MYLOCK)
INTEGER_M,optional :: MYLOCK
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_DESTROY_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_DESTROY_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
END SUBROUTINE OML_DESTROY_LOCK

SUBROUTINE OML_WAIT_EVENT(K,MYLOCK)
INTEGER_M :: K
INTEGER_M,OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  DO
    IF(K == MYLOCK)EXIT
  ENDDO
ELSE
  DO
    IF(K == M_OML_LOCK)EXIT
  ENDDO
ENDIF
END SUBROUTINE OML_WAIT_EVENT

SUBROUTINE OML_SET_EVENT(K,MYLOCK)
INTEGER_M :: K
INTEGER_M,OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=K
ELSE
  M_OML_LOCK=K
ENDIF
END SUBROUTINE OML_SET_EVENT

SUBROUTINE OML_INCR_EVENT(K,MYLOCK)
INTEGER_M :: K
INTEGER_M,intent(inout),OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=MYLOCK+K
ELSE
  M_OML_LOCK=M_OML_LOCK+K
ENDIF
END SUBROUTINE OML_INCR_EVENT

FUNCTION OML_MY_THREAD()
INTEGER_M :: OML_MY_THREAD
INTEGER_M OMP_GET_THREAD_NUM
OML_MY_THREAD = 1
!$ OML_MY_THREAD = OMP_GET_THREAD_NUM()+1
END FUNCTION OML_MY_THREAD

FUNCTION OML_MAX_THREADS()
INTEGER_M :: OML_MAX_THREADS
INTEGER_M OMP_GET_MAX_THREADS
M_OML_MAX_THREADS = 1
!$ M_OML_MAX_THREADS = OMP_GET_MAX_THREADS()
OML_MAX_THREADS = M_OML_MAX_THREADS
END FUNCTION OML_MAX_THREADS

END MODULE YOMOML
