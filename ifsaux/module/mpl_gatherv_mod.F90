MODULE MPL_GATHERV_MOD

!**** MPL_GATHERV Gather data to specific processor

!     Purpose.
!     --------
!     Gather data to specific processor
!     The data may be REAL*4, REAL*8,or INTEGER, one dimensional array
!                     REAL*4,or REAL*8, two dimensional array
!                  or INTEGER scalar

!**   Interface.
!     ----------
!        CALL MPL_GATHERV

!        Input required arguments :
!        -------------------------
!           PSENDBUF -  buffer containing message
!                       (can be type REAL*4, REAL*8 or INTEGER)
!           PRECVBUF -  buffer containing message (required from kroot)
!                       (can be type REAL*4, REAL*8 or INTEGER)
!           KRECVCOUNTS-number of elements received from each process
!                       (required from kroot processor)

!        Input optional arguments :
!        -------------------------
!           KROOT    -  rank of receiveing processor (default 1) 
!           KCOMM    -  Communicator number if different from MPI_COMM_WORLD 
!                       or from that established as the default 
!                       by an MPL communicator routine
!           KRECVDISPL -displacements in PRECVBUF at which to place 
!                       the incoming data
!           CDSTRING -  Character string for ABORT messages
!                       used when KERROR is not provided

!        Output required arguments :
!        -------------------------
!           none

!        Output optional arguments :
!        -------------------------
!           KERROR   -  return error code.     If not supplied, 
!                       MPL_GATHERV aborts when an error is detected.
!     Author.
!     -------
!        D.Dent, M.Hamrud     ECMWF

!     Modifications.
!     --------------
!        Original: 2000-11-23

!     ------------------------------------------------------------------

#include "tsmbkind.h"

USE MPL_MPIF
USE MPL_DATA_MODULE
USE MPL_MESSAGE_MOD
USE MPL_SEND_MOD
USE MPL_RECV_MOD

IMPLICIT NONE

PRIVATE

INTEGER_M :: IR,ISENDCOUNT,IRECVBUFSIZE,ICOMM,IROOT
LOGICAL   :: LLABORT=.TRUE.
INTEGER_M :: IERROR
INTEGER_M :: IDUM,IST,IEND,JK
INTEGER_M :: ITAG=22222
REAL_B    :: ZDUM

INTERFACE MPL_GATHERV
MODULE PROCEDURE MPL_GATHERV_REAL8,MPL_GATHERV_REAL4,MPL_GATHERV_INT,&
               & MPL_GATHERV_INT_SCALAR
END INTERFACE

PUBLIC MPL_GATHERV

CONTAINS

SUBROUTINE MPL_GATHERV_PREAMB1(KCOMM,KROOT)


INTEGER_M,INTENT(IN),OPTIONAL :: KROOT
INTEGER_M,INTENT(IN),OPTIONAL :: KCOMM

IERROR = 0

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_GATHERV: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

IF(PRESENT(KROOT)) THEN
  IROOT=KROOT
ELSE
  IROOT=1
ENDIF


END SUBROUTINE MPL_GATHERV_PREAMB1

SUBROUTINE MPL_GATHERV_PREAMB2(KRECVCOUNTS,KRECVDISPL,KIRECVDISPL,CDSTRING)

INTEGER_M,INTENT(IN) :: KRECVCOUNTS(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:)
INTEGER_M,INTENT(OUT) :: KIRECVDISPL(:) 
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING


IF(SIZE(KRECVCOUNTS)  < MPL_NUMPROC) THEN
  WRITE(MPL_ERRUNIT,*)'MPL_GATHERV: ERROR KRECVCOUNTS DIMENSION=',&
   & SIZE(KRECVCOUNTS)
  CALL MPL_MESSAGE(CDMESSAGE=&
   & 'MPL_GATHERV: ERROR KRECVCOUNTS DIMENSION IS WRONG',LDABORT=LLABORT)
ENDIF
IF(ISENDCOUNT /= KRECVCOUNTS(MPL_RANK)) THEN
  WRITE(MPL_ERRUNIT,*)'MPL_GATHERV: ERROR KRECVCOUNTS INCONSISTENCY ',&
   & ISENDCOUNT,KRECVCOUNTS(MPL_RANK)
  CALL MPL_MESSAGE(CDMESSAGE=&
   & 'MPL_GATHERV: ERROR ISENDCOUNT /= KRECVCOUNTS(MPL_RANK) ',LDABORT=LLABORT)
ENDIF

IF(PRESENT(KRECVDISPL)) THEN
  KIRECVDISPL(:) = KRECVDISPL(:)
ELSE
  KIRECVDISPL(:) = 0
  DO IR=2, MPL_NUMPROC
    KIRECVDISPL(IR) = KIRECVDISPL(IR-1) + KRECVCOUNTS(IR-1)
  ENDDO
ENDIF
DO IR=1, MPL_NUMPROC
  IF(KIRECVDISPL(IR)+KRECVCOUNTS(IR) > IRECVBUFSIZE) THEN
    WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_GATHERV:RECV BUFFER TOO SMALL  ', &
     & IR,KIRECVDISPL(IR),KRECVCOUNTS(IR),IRECVBUFSIZE
    CALL MPL_MESSAGE(CDMESSAGE='MPL_GATHERV',CDSTRING=CDSTRING,LDABORT=LLABORT)
  ENDIF
ENDDO

END SUBROUTINE MPL_GATHERV_PREAMB2

SUBROUTINE MPL_GATHERV_REAL4(PSENDBUF,KROOT,PRECVBUF,KRECVCOUNTS,KRECVDISPL, &
                            & KCOMM,KERROR,CDSTRING)


INTEGER_M,INTENT(IN),OPTIONAL :: KROOT
REAL_M,INTENT(IN) :: PSENDBUF(:)
REAL_M,INTENT(OUT),OPTIONAL  :: PRECVBUF(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVCOUNTS(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: IRECVDISPL(MPL_NUMPROC)


CALL MPL_GATHERV_PREAMB1(KCOMM,KROOT)
ISENDCOUNT = SIZE(PSENDBUF)

IF(MPL_RANK == IROOT) THEN
  IF( .NOT. PRESENT(PRECVBUF)) CALL MPL_MESSAGE(&
   & CDMESSAGE='MPL_GATHERV:RECVBUF MISSING',CDSTRING=CDSTRING,LDABORT=LLABORT)
  IRECVBUFSIZE = SIZE(PRECVBUF)
  CALL MPL_GATHERV_PREAMB2(KRECVCOUNTS,IRECVDISPL,IRECVDISPL,CDSTRING)
  CALL MPI_GATHERV(PSENDBUF(1),ISENDCOUNT,MPI_REAL4,PRECVBUF(1),KRECVCOUNTS, &
   &  IRECVDISPL,MPI_REAL4,IROOT-1,ICOMM,IERROR)
ELSE
  CALL MPI_GATHERV(PSENDBUF(1),ISENDCOUNT,MPI_REAL4,ZDUM,1, &
   &  1,MPI_REAL4,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_GATHERV',&
   & CDSTRING,LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_GATHERV_REAL4

SUBROUTINE MPL_GATHERV_REAL8(PSENDBUF,KROOT,PRECVBUF,KRECVCOUNTS,KRECVDISPL, &
                            & KCOMM,KERROR,CDSTRING)


INTEGER_M,INTENT(IN),OPTIONAL :: KROOT
REAL_B            :: PSENDBUF(:)
REAL_B,OPTIONAL   :: PRECVBUF(:)
INTEGER_M,INTENT(IN) :: KRECVCOUNTS(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: IRECVDISPL(MPL_NUMPROC)


CALL MPL_GATHERV_PREAMB1(KCOMM,KROOT)
ISENDCOUNT = SIZE(PSENDBUF)

IF(MPL_RANK == IROOT) THEN
  IF( .NOT. PRESENT(PRECVBUF)) CALL MPL_MESSAGE(&
   & CDMESSAGE='MPL_GATHERV:RECVBUF MISSING',CDSTRING=CDSTRING,LDABORT=LLABORT)
  IRECVBUFSIZE = SIZE(PRECVBUF)
  CALL MPL_GATHERV_PREAMB2(KRECVCOUNTS,KRECVDISPL,IRECVDISPL,CDSTRING)
  IF(LUSEHLMPI)THEN
    CALL MPI_GATHERV(PSENDBUF(1),ISENDCOUNT,MPI_REAL8,PRECVBUF(1),KRECVCOUNTS,&
     &  IRECVDISPL,MPI_REAL8,IROOT-1,ICOMM,IERROR)
  ELSE
    DO JK=1,MPL_NUMPROC
      IST = IRECVDISPL(JK)+1
      IEND = IST+KRECVCOUNTS(JK)-1
      IF(JK /= MPL_RANK) THEN
        CALL MPL_SEND(MPL_RANK,KTAG=ITAG,KDEST=JK)
        CALL MPL_RECV(PRECVBUF(IST:IEND),KTAG=ITAG,KSOURCE=JK)
      ELSE
        PRECVBUF(IST:IEND) = PSENDBUF(1:ISENDCOUNT)
      ENDIF
    ENDDO
  ENDIF
ELSE
  IF(LUSEHLMPI)THEN
    CALL MPI_GATHERV(PSENDBUF(1),ISENDCOUNT,MPI_REAL8,ZDUM,1, &
     &  1,MPI_REAL8,IROOT-1,ICOMM,IERROR)
  ELSE
    CALL MPL_RECV(IDUM,KTAG=ITAG,KSOURCE=IROOT)
    CALL MPL_SEND(PSENDBUF(1:ISENDCOUNT),KTAG=ITAG,KDEST=IROOT)
  ENDIF
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_GATHERV',CDSTRING,&
   & LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_GATHERV_REAL8

SUBROUTINE MPL_GATHERV_INT(KSENDBUF,KROOT,KRECVBUF,KRECVCOUNTS,KRECVDISPL, &
                            & KCOMM,KERROR,CDSTRING)


INTEGER_M,INTENT(IN),OPTIONAL :: KROOT
INTEGER_M,INTENT(IN)         :: KSENDBUF(:)
INTEGER_M,INTENT(OUT),OPTIONAL :: KRECVBUF(:)
INTEGER_M,INTENT(IN) :: KRECVCOUNTS(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: IRECVDISPL(MPL_NUMPROC)

CALL MPL_GATHERV_PREAMB1(KCOMM,KROOT)
ISENDCOUNT = SIZE(KSENDBUF)

IF(MPL_RANK == IROOT) THEN
  IF( .NOT. PRESENT(KRECVBUF)) CALL MPL_MESSAGE(&
   & CDMESSAGE='MPL_GATHERV:RECVBUF MISSING',CDSTRING=CDSTRING,LDABORT=LLABORT)
  IRECVBUFSIZE = SIZE(KRECVBUF)
  CALL MPL_GATHERV_PREAMB2(KRECVCOUNTS,KRECVDISPL,IRECVDISPL,CDSTRING)
  CALL MPI_GATHERV(KSENDBUF(1),ISENDCOUNT,MPI_INTEGER,KRECVBUF(1),&
   & KRECVCOUNTS,IRECVDISPL,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
ELSE
  CALL MPI_GATHERV(KSENDBUF(1),ISENDCOUNT,MPI_INTEGER,ZDUM,1, &
   &  1,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_GATHERV',CDSTRING,LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_GATHERV_INT

SUBROUTINE MPL_GATHERV_INT_SCALAR(KSENDBUF,KROOT,KRECVBUF,KRECVCOUNTS,&
 & KRECVDISPL,KCOMM,KERROR,CDSTRING)


INTEGER_M,INTENT(IN) :: KSENDBUF
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT
INTEGER_M,INTENT(OUT),OPTIONAL :: KRECVBUF(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVCOUNTS(:) ! Not used; for compatibility only
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: IRECVDISPL(MPL_NUMPROC),IRECVCOUNTS(MPL_NUMPROC)

CALL MPL_GATHERV_PREAMB1(KCOMM,KROOT)
ISENDCOUNT = 1

IF(MPL_RANK == IROOT) THEN
  IF( .NOT. PRESENT(KRECVBUF)) CALL MPL_MESSAGE(&
   & CDMESSAGE='MPL_GATHERV:RECVBUF MISSING',CDSTRING=CDSTRING,LDABORT=LLABORT)
  IRECVBUFSIZE = SIZE(KRECVBUF)
  IF(PRESENT(KRECVDISPL)) THEN
    IRECVCOUNTS(:) = 1
    CALL MPL_GATHERV_PREAMB2(IRECVCOUNTS,KRECVDISPL,IRECVDISPL,CDSTRING)
    CALL MPI_GATHERV(KSENDBUF,ISENDCOUNT,MPI_INTEGER,KRECVBUF(1),&
     & IRECVCOUNTS,IRECVDISPL,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
  ELSE
    IF(IRECVBUFSIZE < MPL_NUMPROC) THEN
      CALL MPL_MESSAGE(CDMESSAGE='MPL_GATHERV:IRECVBUFSIZE < MPL_NUMPROC',&
       & CDSTRING=CDSTRING,LDABORT=LLABORT)
    ENDIF
    CALL MPI_GATHER(KSENDBUF,ISENDCOUNT,MPI_INTEGER,KRECVBUF(1),&
     & ISENDCOUNT,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
  ENDIF
ELSE
  IF(PRESENT(KRECVDISPL)) THEN
    CALL MPI_GATHERV(KSENDBUF,ISENDCOUNT,MPI_INTEGER,ZDUM,1, &
     &  1,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
  ELSE
    CALL MPI_GATHER(KSENDBUF,ISENDCOUNT,MPI_INTEGER,ZDUM,&
     & 1,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
  ENDIF
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_GATHERV',CDSTRING,LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_GATHERV_INT_SCALAR

SUBROUTINE MPL_GATHERV_REAL8_SCALAR(PSENDBUF,KROOT,PRECVBUF,KRECVCOUNTS,&
 & KRECVDISPL,KCOMM,KERROR,CDSTRING)


REAL_B,INTENT(IN) :: PSENDBUF
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT
REAL_B,INTENT(OUT),OPTIONAL :: PRECVBUF(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVCOUNTS(:) ! Not used; for compatibility only
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: IRECVDISPL(MPL_NUMPROC),IRECVCOUNTS(MPL_NUMPROC)

CALL MPL_GATHERV_PREAMB1(KCOMM,KROOT)
ISENDCOUNT = 1

IF(MPL_RANK == IROOT) THEN
  IF( .NOT. PRESENT(PRECVBUF)) CALL MPL_MESSAGE(&
   & CDMESSAGE='MPL_GATHERV:RECVBUF MISSING',CDSTRING=CDSTRING,LDABORT=LLABORT)
  IRECVBUFSIZE = SIZE(PRECVBUF)
  IF(PRESENT(KRECVDISPL)) THEN
    IRECVCOUNTS(:) = 1
    CALL MPL_GATHERV_PREAMB2(IRECVCOUNTS,KRECVDISPL,IRECVDISPL,CDSTRING)
    CALL MPI_GATHERV(PSENDBUF,ISENDCOUNT,MPI_REAL8,PRECVBUF(1),&
     & IRECVCOUNTS,IRECVDISPL,MPI_REAL8,IROOT-1,ICOMM,IERROR)
  ELSE
    IF(IRECVBUFSIZE < MPL_NUMPROC) THEN
      CALL MPL_MESSAGE(CDMESSAGE='MPL_GATHERV:IRECVBUFSIZE < MPL_NUMPROC',&
       & CDSTRING=CDSTRING,LDABORT=LLABORT)
    ENDIF
    CALL MPI_GATHER(PSENDBUF,ISENDCOUNT,MPI_REAL8,PRECVBUF(1),&
     & ISENDCOUNT,MPI_REAL8,IROOT-1,ICOMM,IERROR)
  ENDIF
ELSE
  IF(PRESENT(KRECVDISPL)) THEN
    CALL MPI_GATHERV(PSENDBUF,ISENDCOUNT,MPI_REAL8,ZDUM,1, &
     &  1,MPI_REAL8,IROOT-1,ICOMM,IERROR)
  ELSE
    CALL MPI_GATHER(PSENDBUF,ISENDCOUNT,MPI_REAL8,ZDUM,&
     & 1,MPI_REAL8,IROOT-1,ICOMM,IERROR)
  ENDIF
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_GATHERV',CDSTRING,LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_GATHERV_REAL8_SCALAR

END MODULE MPL_GATHERV_MOD
