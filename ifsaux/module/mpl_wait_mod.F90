MODULE MPL_WAIT_MOD

!**** MPL_WAIT Waits for completion

!     Purpose.
!     --------
!     Returns control when the operation(s) identified by the request
!     is completed.
!     Normally used in conjunction with non-blocking buffering type

!**   Interface.
!     ----------
!        CALL MPL_WAIT

!        Input required arguments :
!        -------------------------
!           PBUF     -  array with same size and shape as buffer
!                       used for MPL_SEND or MPL_RECV
!           KREQUEST -  array or scalar containing
!                       Communication request(s)
!                       as provided by MPL_RECV or MPL_SEND

!        Input optional arguments :
!        -------------------------
!           CDSTRING -  Character string for ABORT messages
!                       used when KERROR is not provided

!        Output required arguments :
!        -------------------------
!           none

!        Output optional arguments :
!        -------------------------
!           KCOUNT   -  must be the same size and shape as KREQUEST
!                       contains number of items sent/received
!           KERROR   -  return error code.     If not supplied, 
!                       MPL_WAIT aborts when an error is detected.
!     Author.
!     -------
!        D.Dent, M.Hamrud     ECMWF

!     Modifications.
!     --------------
!        Original: 2000-09-01

!     ------------------------------------------------------------------

#include "tsmbkind.h"

USE MPL_DATA_MODULE
USE MPL_MESSAGE_MOD

IMPLICIT NONE

PRIVATE

INTEGER_M :: IWAITERR,ICOUNTERR,JL,IREQLEN,ICOUNT

INTERFACE MPL_WAIT
MODULE PROCEDURE MPL_WAITS_REAL4,MPL_WAITS_REAL8,MPL_WAITS_INT, &
               & MPL_WAIT1_REAL4,MPL_WAIT1_REAL8,MPL_WAIT1_INT, &
               & MPL_WAITS_INT2,MPL_WAIT1_INT2
END INTERFACE

PUBLIC MPL_WAIT

CONTAINS 

SUBROUTINE MPL_WAITS_REAL4(PBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

REAL_M                        :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KREQUEST(:)
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT(SIZE(KREQUEST))
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,SIZE(KREQUEST))
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=SIZE(KREQUEST)
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  IF(SIZE(KCOUNT) /= IREQLEN) THEN
    CALL MPL_MESSAGE( &
    & CDMESSAGE='MPL_WAIT: KCOUNT AND KREQUEST INCONSISTENT ', &
    & CDSTRING=CDSTRING,LDABORT=LLABORT)
  ENDIF
  DO JL=1,IREQLEN
    CALL MPI_GET_COUNT(IWAIT_STATUS(1,JL),MPI_REAL4,KCOUNT(JL),ICOUNTERR)
  ENDDO
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAITS_REAL4

SUBROUTINE MPL_WAIT1_REAL4(PBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

REAL_M                      :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KREQUEST
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,1)
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=1
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  CALL MPI_GET_COUNT(IWAIT_STATUS(1,1),MPI_REAL4,KCOUNT,ICOUNTERR)
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAIT1_REAL4

SUBROUTINE MPL_WAITS_REAL8(PBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

REAL_B                      :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KREQUEST(:)
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT(SIZE(KREQUEST))
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,SIZE(KREQUEST))
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=SIZE(KREQUEST)
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  IF(SIZE(KCOUNT) /= IREQLEN) THEN
    CALL MPL_MESSAGE( &
    & CDMESSAGE='MPL_WAIT: KCOUNT AND KREQUEST INCONSISTENT ', &
    & CDSTRING=CDSTRING,LDABORT=LLABORT)
  ENDIF
  DO JL=1,IREQLEN
    CALL MPI_GET_COUNT(IWAIT_STATUS(1,JL),MPI_REAL8,KCOUNT(JL),ICOUNTERR)
  ENDDO
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAITS_REAL8

SUBROUTINE MPL_WAIT1_REAL8(PBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

REAL_B                      :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KREQUEST
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,1)
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=1
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  CALL MPI_GET_COUNT(IWAIT_STATUS(1,1),MPI_REAL8,KCOUNT,ICOUNTERR)
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAIT1_REAL8

SUBROUTINE MPL_WAITS_INT(KBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

INTEGER_M                     :: KBUF(:)
INTEGER_M,INTENT(IN)          :: KREQUEST(:)
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT(SIZE(KREQUEST))
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,SIZE(KREQUEST))
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=SIZE(KREQUEST)
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  IF(SIZE(KCOUNT) /= IREQLEN) THEN
    CALL MPL_MESSAGE( &
    & CDMESSAGE='MPL_WAIT: KCOUNT AND KREQUEST INCONSISTENT ', &
    & CDSTRING=CDSTRING,LDABORT=LLABORT)
  ENDIF
  DO JL=1,IREQLEN
    CALL MPI_GET_COUNT(IWAIT_STATUS(1,JL),MPI_INTEGER,KCOUNT(JL),ICOUNTERR)
  ENDDO
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAITS_INT

SUBROUTINE MPL_WAIT1_INT(KBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

INTEGER_M                     :: KBUF(:)
INTEGER_M,INTENT(IN)          :: KREQUEST
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,1)
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=1
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  CALL MPI_GET_COUNT(IWAIT_STATUS(1,1),MPI_INTEGER,KCOUNT,ICOUNTERR)
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAIT1_INT

SUBROUTINE MPL_WAITS_INT2(KBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

INTEGER_M                     :: KBUF(:,:)
INTEGER_M,INTENT(IN)          :: KREQUEST(:)
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT(SIZE(KREQUEST))
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,SIZE(KREQUEST))
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=SIZE(KREQUEST)
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  IF(SIZE(KCOUNT) /= IREQLEN) THEN
    CALL MPL_MESSAGE( &
    & CDMESSAGE='MPL_WAIT: KCOUNT AND KREQUEST INCONSISTENT ', &
    & CDSTRING=CDSTRING,LDABORT=LLABORT)
  ENDIF
  DO JL=1,IREQLEN
    CALL MPI_GET_COUNT(IWAIT_STATUS(1,JL),MPI_INTEGER,KCOUNT(JL),ICOUNTERR)
  ENDDO
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAITS_INT2

SUBROUTINE MPL_WAIT1_INT2(KBUF,KREQUEST,KCOUNT,KERROR,CDSTRING)

#include "mpif.h"

INTEGER_M                     :: KBUF(:,:)
INTEGER_M,INTENT(IN)          :: KREQUEST
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
INTEGER_M,INTENT(OUT),OPTIONAL :: KCOUNT
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR

INTEGER_M :: IWAIT_STATUS(MPI_STATUS_SIZE,1)
LOGICAL :: LLABORT=.TRUE.

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_WAIT: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IREQLEN=1
CALL MPI_WAITALL(IREQLEN,KREQUEST,IWAIT_STATUS,IWAITERR)

IF(PRESENT(KCOUNT))THEN
  CALL MPI_GET_COUNT(IWAIT_STATUS(1,1),MPI_INTEGER,KCOUNT,ICOUNTERR)
ENDIF

IF(PRESENT(KERROR))THEN
  KERROR=IWAITERR+ICOUNTERR
ELSE IF(IWAITERR /= 0) THEN
  CALL MPL_MESSAGE(IWAITERR,'MPL_WAIT_WAITING',CDSTRING,LDABORT=LLABORT)
ELSE IF(ICOUNTERR /= 0) THEN
  CALL MPL_MESSAGE(ICOUNTERR,'MPL_WAIT_COUNT',CDSTRING,LDABORT=LLABORT)
ENDIF

RETURN
END SUBROUTINE MPL_WAIT1_INT2

END MODULE MPL_WAIT_MOD
