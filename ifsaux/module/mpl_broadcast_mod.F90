MODULE MPL_BROADCAST_MOD

!**** MPL_BROADCAST Message broadcast

!     Purpose.
!     --------
!     Broadcasts a message from the process with rank root
!     to all processes in the group.

!**   Interface.
!     ----------
!        CALL MPL_BROADCAST

!        Input required arguments :
!        -------------------------
!           PBUF     -  buffer containing message
!                       (can be type REAL*4, REAL*8 or INTEGER)
!           KTAG     -  message tag

!        Input optional arguments :
!        -------------------------
!           KROOT    -  number of root process (default=1)
!           KCOMM    -  Communicator number if different from MPI_COMM_WORLD 
!                       or from that established as the default 
!                       by an MPL communicator routine
!           CDSTRING -  Character string for ABORT messages
!                       used when KERROR is not provided
!                   

!        Output required arguments :
!        -------------------------
!           none

!        Output optional arguments :
!        -------------------------
!           KERROR   -  return error code.     If not supplied, 
!                       MPL_BROADCAST aborts when an error is detected.
!     Author.
!     -------
!        D.Dent, M.Hamrud, S.Saarinen    ECMWF

!     Modifications.
!     --------------
!        Original: 2000-09-01

!     ------------------------------------------------------------------

#include "tsmbkind.h"

USE MPL_MPIF
USE MPL_DATA_MODULE
USE MPL_MESSAGE_MOD
USE MPL_SEND_MOD
USE MPL_RECV_MOD
USE MPL_BARRIER_MOD
USE MPL_MYRANK_MOD

IMPLICIT NONE
PRIVATE

INTEGER_M :: ICOUNT,ICOMM,IERROR,IPROC,IROOT,IOUNT,IPL_NUMPROC,IPL_MYRANK
INTEGER_M :: IMAXMSG, ICHUNKS, ISTS, IENS, ILENS, ITAG, IDUM, JMESS
INTEGER_M :: JCOL, IROWS, ICOLS
LOGICAL :: LLABORT=.TRUE.

INTERFACE MPL_BROADCAST
MODULE PROCEDURE MPL_BROADCAST_REAL4,MPL_BROADCAST_REAL8, &
     & MPL_BROADCAST_REAL42,MPL_BROADCAST_REAL82,         &
     & MPL_BROADCAST_INT,MPL_BROADCAST_INT2,MPL_BROADCAST_INT_SCALAR
END INTERFACE

PUBLIC MPL_BROADCAST

CONTAINS

SUBROUTINE MPL_BROADCAST_PREAMB1(KCOMM,KROOT)


INTEGER_M,INTENT(IN),OPTIONAL :: KROOT
INTEGER_M,INTENT(IN),OPTIONAL :: KCOMM

IERROR = 0

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_BROADCAST: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

IF(ICOMM == MPL_COMM) THEN
  IPL_NUMPROC = MPL_NUMPROC
  IPL_MYRANK  = MPL_RANK
ELSE
  CALL MPI_COMM_SIZE(ICOMM,IPL_NUMPROC,IERROR)
  IPL_MYRANK  = MPL_MYRANK(ICOMM)
ENDIF

IF(PRESENT(KROOT)) THEN
  IROOT=KROOT
ELSE
  IROOT=1
ENDIF


END SUBROUTINE MPL_BROADCAST_PREAMB1

SUBROUTINE MPL_BROADCAST_REAL4(PBUF,KTAG,KROOT,&
                               KCOMM,KERROR,CDSTRING)

REAL_M            :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) THEN
  IF(PRESENT(KERROR)) THEN
    KERROR=0
  ENDIF
  RETURN
ENDIF

CALL MPL_BROADCAST_PREAMB1(KCOMM,KROOT)

ICOUNT = SIZE(PBUF)

IF( .NOT. LUSEHLMPI) THEN
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  IMAXMSG=0.9*MPL_MBX_SIZE/4
  ICHUNKS=(ICOUNT-1)/IMAXMSG+1
  ISTS=1
  IF(IPL_MYRANK == IROOT) THEN
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      DO IPROC=1,IPL_NUMPROC
        IF(IPROC /= IPL_MYRANK) THEN
          IF (ILENS > 0) THEN
            CALL MPL_SEND(PBUF(ISTS:IENS),KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ELSE
            CALL MPL_SEND(IDUM,KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ENDIF
          IF(IERROR /= 0 ) &
            CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(SEND)',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDDO
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ELSE
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF (ILENS > 0) THEN
        CALL MPL_RECV(PBUF(ISTS:IENS),KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= ILENS) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG  RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ELSE
        CALL MPL_RECV(IDUM,KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG DUMMY RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0) &
        CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(RECV)',CDSTRING,LDABORT=LLABORT)
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ENDIF
ELSE
  CALL MPI_BCAST(PBUF,ICOUNT,MPI_REAL4,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF


END SUBROUTINE MPL_BROADCAST_REAL4

SUBROUTINE MPL_BROADCAST_REAL8(PBUF,KTAG,KROOT,&
                               KCOMM,KERROR,CDSTRING)

REAL_B            :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) RETURN


CALL MPL_BROADCAST_PREAMB1(KCOMM,KROOT)

ICOUNT = SIZE(PBUF)

IF( .NOT. LUSEHLMPI) THEN
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  IMAXMSG=0.9*MPL_MBX_SIZE/8
  ICHUNKS=(ICOUNT-1)/IMAXMSG+1
  ISTS=1
  IF(IPL_MYRANK == IROOT) THEN
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      DO IPROC=1,IPL_NUMPROC
        IF(IPROC /= IPL_MYRANK) THEN
          IF (ILENS > 0) THEN
            CALL MPL_SEND(PBUF(ISTS:IENS),KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ELSE
            CALL MPL_SEND(IDUM,KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ENDIF
          IF(IERROR /= 0 ) &
            CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(SEND)',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDDO
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ELSE
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF (ILENS > 0) THEN
        CALL MPL_RECV(PBUF(ISTS:IENS),KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= ILENS) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG  RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ELSE
        CALL MPL_RECV(IDUM,KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG DUMMY RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0 ) &
        CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(RECV)',CDSTRING,LDABORT=LLABORT)
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ENDIF
ELSE
  CALL MPI_BCAST(PBUF,ICOUNT,MPI_REAL8,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF


END SUBROUTINE MPL_BROADCAST_REAL8


SUBROUTINE MPL_BROADCAST_REAL42(PBUF,KTAG,KROOT,KCOMM,KERROR,CDSTRING)

REAL_M            :: PBUF(:,:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) RETURN

IROWS=SIZE(PBUF,DIM=1)
ICOLS=SIZE(PBUF,DIM=2)
DO JCOL=1,ICOLS
  CALL MPL_BROADCAST(PBUF(1:IROWS,JCOL),KTAG,KROOT,KCOMM,KERROR,CDSTRING)
ENDDO

END SUBROUTINE MPL_BROADCAST_REAL42


SUBROUTINE MPL_BROADCAST_REAL82(PBUF,KTAG,KROOT,&
                                KCOMM,KERROR,CDSTRING)

REAL_B            :: PBUF(:,:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) RETURN

IROWS=SIZE(PBUF,DIM=1)
ICOLS=SIZE(PBUF,DIM=2)
DO JCOL=1,ICOLS
  CALL MPL_BROADCAST(PBUF(1:IROWS,JCOL),KTAG,KROOT,KCOMM,KERROR,&
   & CDSTRING)
ENDDO

END SUBROUTINE MPL_BROADCAST_REAL82


SUBROUTINE MPL_BROADCAST_INT(KBUF,KTAG,KROOT,&
                             KCOMM,KERROR,CDSTRING)

INTEGER_M           :: KBUF(:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) RETURN

CALL MPL_BROADCAST_PREAMB1(KCOMM,KROOT)

ICOUNT = SIZE(KBUF)

IF( .NOT. LUSEHLMPI) THEN
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  IMAXMSG=0.9*MPL_MBX_SIZE/4
  ICHUNKS=(ICOUNT-1)/IMAXMSG+1
  ISTS=1
  IF(IPL_MYRANK == IROOT) THEN
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      DO IPROC=1,IPL_NUMPROC
        IF(IPROC /= IPL_MYRANK) THEN
          IF (ILENS > 0) THEN
            CALL MPL_SEND(KBUF(ISTS:IENS),KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ELSE
            CALL MPL_SEND(IDUM,KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ENDIF
          IF(IERROR /= 0 ) &
            CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(SEND)',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDDO
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ELSE
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF (ILENS > 0) THEN
        CALL MPL_RECV(KBUF(ISTS:IENS),KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= ILENS) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG  RECEIVE ', &
           & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ELSE
        CALL MPL_RECV(IDUM,KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG DUMMY RECEIVE ', &
           & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0 ) &
        CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(RECV)',CDSTRING,LDABORT=LLABORT)
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ENDIF
ELSE
  CALL MPI_BCAST(KBUF,ICOUNT,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF


END SUBROUTINE MPL_BROADCAST_INT


SUBROUTINE MPL_BROADCAST_INT2(KBUF,KTAG,KROOT,&
                              KCOMM,KERROR,CDSTRING)

INTEGER_M           :: KBUF(:,:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) RETURN

IROWS=SIZE(KBUF,DIM=1)
ICOLS=SIZE(KBUF,DIM=2)
DO JCOL=1,ICOLS
  CALL MPL_BROADCAST(KBUF(1:IROWS,JCOL),KTAG,KROOT,KCOMM,KERROR,CDSTRING)
ENDDO

END SUBROUTINE MPL_BROADCAST_INT2


SUBROUTINE MPL_BROADCAST_INT_SCALAR(KBUF,KTAG,KROOT,&
                                    KCOMM,KERROR,CDSTRING)

INTEGER_M           :: KBUF
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) RETURN

CALL MPL_BROADCAST_PREAMB1(KCOMM,KROOT)

ICOUNT = 1


IF( .NOT. LUSEHLMPI ) THEN
  IF(IPL_MYRANK == IROOT) THEN
    DO IPROC=1,IPL_NUMPROC
      IF(IPROC /= IPL_MYRANK) THEN
        CALL MPL_SEND(KBUF,KDEST=IPROC,KTAG=KTAG,KERROR=IERROR)
      ENDIF
    ENDDO
  ELSE
    CALL MPL_RECV(KBUF,KSOURCE=IROOT,KTAG=KTAG,KERROR=IERROR)
  ENDIF
ELSE
  CALL MPI_BCAST(KBUF,ICOUNT,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF


END SUBROUTINE MPL_BROADCAST_INT_SCALAR

END MODULE MPL_BROADCAST_MOD
