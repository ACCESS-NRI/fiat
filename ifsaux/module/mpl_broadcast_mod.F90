MODULE MPL_BROADCAST_MOD

!**** MPL_BROADCAST Message broadcast

!     Purpose.
!     --------
!     Broadcasts a message from the process with rank root
!     to all processes in the group.

!**   Interface.
!     ----------
!        CALL MPL_BROADCAST

!        Input required arguments :
!        -------------------------
!           PBUF     -  buffer containing message
!                       (can be type REAL*4, REAL*8 or INTEGER)
!           KTAG     -  message tag

!        Input optional arguments :
!        -------------------------
!           KROOT    -  number of root process (default=1)
!           KCOMM    -  Communicator number if different from MPI_COMM_WORLD 
!                       or from that established as the default 
!                       by an MPL communicator routine
!           CDSTRING -  Character string for ABORT messages
!                       used when KERROR is not provided
!           LDCOMPAT - Compatibility flag for earlier implementations
!                      where MPE_BROADCAST was used as multiple MPE_SENDs
!                      by the root and receiving processes called
!                      MPE_RECV directly (see WAM-library for instance)
!                      default=.FALSE. ! All procs (also receivers) can call
!                                        i.e. barrier & chunking available
!                                        inside MPL_BROADCAST
!                      when .TRUE., no. of chunks set to 1 and no barriers
!                   

!        Output required arguments :
!        -------------------------
!           none

!        Output optional arguments :
!        -------------------------
!           KERROR   -  return error code.     If not supplied, 
!                       MPL_BROADCAST aborts when an error is detected.
!     Author.
!     -------
!        D.Dent, M.Hamrud, S.Saarinen    ECMWF

!     Modifications.
!     --------------
!        Original: 2000-09-01

!     ------------------------------------------------------------------

#include "tsmbkind.h"

USE MPL_MPIF
USE MPL_DATA_MODULE
USE MPL_MESSAGE_MOD
USE MPL_SEND_MOD
USE MPL_RECV_MOD
USE MPL_BARRIER_MOD

IMPLICIT NONE
PRIVATE

INTEGER_M :: ICOUNT,ICOMM,IERROR,IPROC,IROOT,IOUNT
INTEGER_M :: IMAXMSG, ICHUNKS, ISTS, IENS, ILENS, ITAG, IDUM, JMESS
INTEGER_M :: JCOL, IROWS, ICOLS
LOGICAL :: LLABORT=.TRUE.
LOGICAL :: LLCOMPAT

INTERFACE MPL_BROADCAST
MODULE PROCEDURE MPL_BROADCAST_REAL4,MPL_BROADCAST_REAL8, &
     & MPL_BROADCAST_REAL42,MPL_BROADCAST_REAL82,         &
     & MPL_BROADCAST_INT,MPL_BROADCAST_INT2,MPL_BROADCAST_INT_SCALAR
END INTERFACE

PUBLIC MPL_BROADCAST

CONTAINS

SUBROUTINE MPL_BROADCAST_REAL4(PBUF,KTAG,KROOT,&
                               KCOMM,KERROR,CDSTRING,&
                               LDCOMPAT)

REAL_M            :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
logical,INTENT(IN),OPTIONAL :: LDCOMPAT

IF (MPL_NUMPROC == 1) THEN
  IF(PRESENT(KERROR)) THEN
    KERROR=0
  ENDIF
  RETURN
ENDIF

IF(PRESENT(KROOT)) THEN
  IROOT=KROOT
ELSE
  IROOT=1
ENDIF

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

IF(PRESENT(LDCOMPAT)) THEN
  LLCOMPAT=LDCOMPAT
ELSE
  LLCOMPAT=.FALSE.
ENDIF

ICOUNT = SIZE(PBUF)
IERROR = 0

IF(LLCOMPAT) THEN ! Compatibility mode with older versions
  IF(MPL_RANK == IROOT) THEN
    DO IPROC=1,MPL_NUMPROC
      IF(IPROC /= MPL_RANK) THEN
        CALL MPL_SEND(PBUF,KDEST=IPROC,KTAG=KTAG,KERROR=IERROR)
      ENDIF
    ENDDO
  ELSE
    CALL MPL_RECV(PBUF,KSOURCE=IROOT,KTAG=KTAG,KERROR=IERROR)
  ENDIF
ELSEIF( .NOT. LUSEHLMPI) THEN
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  IMAXMSG=0.9*MPL_MBX_SIZE/4
  ICHUNKS=(ICOUNT-1)/IMAXMSG+1
  ISTS=1
  IF(MPL_RANK == IROOT) THEN
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      DO IPROC=1,MPL_NUMPROC
        IF(IPROC /= MPL_RANK) THEN
          IF (ILENS > 0) THEN
            CALL MPL_SEND(PBUF(ISTS:IENS),KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ELSE
            CALL MPL_SEND(IDUM,KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ENDIF
          IF(IERROR /= 0 ) &
            CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(SEND)',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDDO
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ELSE
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF (ILENS > 0) THEN
        CALL MPL_RECV(PBUF(ISTS:IENS),KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= ILENS) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG  RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ELSE
        CALL MPL_RECV(IDUM,KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG DUMMY RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0) &
        CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(RECV)',CDSTRING,LDABORT=LLABORT)
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ENDIF
ELSE
  CALL MPI_BCAST(PBUF,ICOUNT,MPI_REAL4,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,L5,5I8)') ' MPL_BROADCAST ',LLCOMPAT,ICOUNT,IROOT,KTAG,ICOMM
ENDIF

END SUBROUTINE MPL_BROADCAST_REAL4

SUBROUTINE MPL_BROADCAST_REAL8(PBUF,KTAG,KROOT,&
                               KCOMM,KERROR,CDSTRING,&
                               LDCOMPAT)

REAL_B            :: PBUF(:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
logical,INTENT(IN),OPTIONAL :: LDCOMPAT

IF (MPL_NUMPROC == 1) RETURN

IF(PRESENT(KROOT)) THEN
  IROOT=KROOT
ELSE
  IROOT=1
ENDIF

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

IF(PRESENT(LDCOMPAT)) THEN
  LLCOMPAT=LDCOMPAT
ELSE
  LLCOMPAT=.FALSE.
ENDIF

ICOUNT = SIZE(PBUF)
IERROR = 0

IF(LLCOMPAT) THEN ! Compatibility mode with older versions
  IF(MPL_RANK == IROOT) THEN
    DO IPROC=1,MPL_NUMPROC
      IF(IPROC /= MPL_RANK) THEN
        CALL MPL_SEND(PBUF,KDEST=IPROC,KTAG=KTAG,KERROR=IERROR)
      ENDIF
    ENDDO
  ELSE
    CALL MPL_RECV(PBUF,KSOURCE=IROOT,KTAG=KTAG,KERROR=IERROR)
  ENDIF
ELSEIF( .NOT. LUSEHLMPI) THEN
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  IMAXMSG=0.9*MPL_MBX_SIZE/8
  ICHUNKS=(ICOUNT-1)/IMAXMSG+1
  ISTS=1
  IF(MPL_RANK == IROOT) THEN
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      DO IPROC=1,MPL_NUMPROC
        IF(IPROC /= MPL_RANK) THEN
          IF (ILENS > 0) THEN
            CALL MPL_SEND(PBUF(ISTS:IENS),KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ELSE
            CALL MPL_SEND(IDUM,KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ENDIF
          IF(IERROR /= 0 ) &
            CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(SEND)',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDDO
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ELSE
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF (ILENS > 0) THEN
        CALL MPL_RECV(PBUF(ISTS:IENS),KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= ILENS) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG  RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ELSE
        CALL MPL_RECV(IDUM,KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG DUMMY RECEIVE ', &
          & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0 ) &
        CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(RECV)',CDSTRING,LDABORT=LLABORT)
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ENDIF
ELSE
  CALL MPI_BCAST(PBUF,ICOUNT,MPI_REAL8,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,L5,5I8)') ' MPL_BROADCAST ',LLCOMPAT,ICOUNT,IROOT,KTAG,ICOMM
ENDIF

END SUBROUTINE MPL_BROADCAST_REAL8


SUBROUTINE MPL_BROADCAST_REAL42(PBUF,KTAG,KROOT,KCOMM,KERROR,CDSTRING)

REAL_M            :: PBUF(:,:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

IF (MPL_NUMPROC == 1) RETURN

IROWS=size(PBUF,dim=1)
ICOLS=size(PBUF,dim=2)
DO JCOL=1,ICOLS
  CALL MPL_BROADCAST(PBUF(1:IROWS,JCOL),KTAG,KROOT,KCOMM,KERROR,CDSTRING)
ENDDO

END SUBROUTINE MPL_BROADCAST_REAL42


SUBROUTINE MPL_BROADCAST_REAL82(PBUF,KTAG,KROOT,&
                                KCOMM,KERROR,CDSTRING,&
                                LDCOMPAT)

REAL_B            :: PBUF(:,:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
logical,INTENT(IN),OPTIONAL :: LDCOMPAT

IF (MPL_NUMPROC == 1) RETURN

IROWS=SIZE(PBUF,DIM=1)
ICOLS=SIZE(PBUF,DIM=2)
DO JCOL=1,ICOLS
  CALL MPL_BROADCAST(PBUF(1:IROWS,JCOL),KTAG,KROOT,KCOMM,KERROR,&
   & CDSTRING,LDCOMPAT)
ENDDO

END SUBROUTINE MPL_BROADCAST_REAL82


SUBROUTINE MPL_BROADCAST_INT(KBUF,KTAG,KROOT,&
                             KCOMM,KERROR,CDSTRING,&
                             LDCOMPAT)

INTEGER_M           :: KBUF(:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
logical,INTENT(IN),OPTIONAL :: LDCOMPAT

IF (MPL_NUMPROC == 1) RETURN

IF(PRESENT(KROOT)) THEN
  IROOT=KROOT
ELSE
  IROOT=1
ENDIF

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

IF(PRESENT(LDCOMPAT)) THEN
  LLCOMPAT=LDCOMPAT
ELSE
  LLCOMPAT=.FALSE.
ENDIF

ICOUNT = SIZE(KBUF)
IERROR = 0

IF(LLCOMPAT) THEN ! Compatibility mode with older versions
  IF(MPL_RANK == IROOT) THEN
    DO IPROC=1,MPL_NUMPROC
      IF(IPROC /= MPL_RANK) THEN
        CALL MPL_SEND(KBUF,KDEST=IPROC,KTAG=KTAG,KERROR=IERROR)
      ENDIF
    ENDDO
  ELSE
    CALL MPL_RECV(KBUF,KSOURCE=IROOT,KTAG=KTAG,KERROR=IERROR)
  ENDIF
ELSEIF( .NOT. LUSEHLMPI) THEN
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  IMAXMSG=0.9*MPL_MBX_SIZE/4
  ICHUNKS=(ICOUNT-1)/IMAXMSG+1
  ISTS=1
  IF(MPL_RANK == IROOT) THEN
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      DO IPROC=1,MPL_NUMPROC
        IF(IPROC /= MPL_RANK) THEN
          IF (ILENS > 0) THEN
            CALL MPL_SEND(KBUF(ISTS:IENS),KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ELSE
            CALL MPL_SEND(IDUM,KDEST=IPROC,KTAG=ITAG,KERROR=IERROR)
          ENDIF
          IF(IERROR /= 0 ) &
            CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(SEND)',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDDO
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ELSE
    DO JMESS=1,ICHUNKS
      IF(JMESS>1) CALL MPL_BARRIER(ICOMM,CDSTRING)
      ITAG  = KTAG+JMESS
      ILENS = MIN(ICOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF (ILENS > 0) THEN
        CALL MPL_RECV(KBUF(ISTS:IENS),KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= ILENS) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG  RECEIVE ', &
           & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ELSE
        CALL MPL_RECV(IDUM,KSOURCE=IROOT,KTAG=ITAG,KERROR=IERROR,KOUNT=IOUNT)
        IF (IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,6I10)')'WRONG DUMMY RECEIVE ', &
           & IROOT, ITAG, ISTS, IENS, ILENS, IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0 ) &
        CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST(RECV)',CDSTRING,LDABORT=LLABORT)
      IF (ILENS > 0) ISTS = ISTS + ILENS
    ENDDO
  ENDIF
ELSE
  CALL MPI_BCAST(KBUF,ICOUNT,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,L5,5I8)') ' MPL_BROADCAST ',LLCOMPAT,ICOUNT,IROOT,KTAG,ICOMM
ENDIF

END SUBROUTINE MPL_BROADCAST_INT


SUBROUTINE MPL_BROADCAST_INT2(KBUF,KTAG,KROOT,&
                              KCOMM,KERROR,CDSTRING,&
                              LDCOMPAT)

INTEGER_M           :: KBUF(:,:)
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
logical,INTENT(IN),OPTIONAL :: LDCOMPAT

IF (MPL_NUMPROC == 1) RETURN

IROWS=size(KBUF,dim=1)
ICOLS=size(KBUF,dim=2)
DO JCOL=1,ICOLS
  CALL MPL_BROADCAST(KBUF(1:IROWS,JCOL),KTAG,KROOT,KCOMM,KERROR,CDSTRING,LDCOMPAT)
ENDDO

END SUBROUTINE MPL_BROADCAST_INT2


SUBROUTINE MPL_BROADCAST_INT_SCALAR(KBUF,KTAG,KROOT,&
                                    KCOMM,KERROR,CDSTRING,&
                                    LDCOMPAT)

INTEGER_M           :: KBUF
INTEGER_M,INTENT(IN)          :: KTAG
INTEGER_M,INTENT(IN),OPTIONAL :: KROOT,KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING
logical,INTENT(IN),OPTIONAL :: LDCOMPAT

IF (MPL_NUMPROC == 1) RETURN

IF(PRESENT(KROOT)) THEN
  IROOT=KROOT
ELSE
  IROOT=1
ENDIF

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

ICOUNT = 1

IF(PRESENT(LDCOMPAT)) THEN
  LLCOMPAT=LDCOMPAT
ELSE
  LLCOMPAT=.FALSE.
ENDIF

IF( .NOT. LUSEHLMPI .OR. LLCOMPAT) THEN
  IF(MPL_RANK == IROOT) THEN
    DO IPROC=1,MPL_NUMPROC
      IF(IPROC /= MPL_RANK) THEN
        CALL MPL_SEND(KBUF,KDEST=IPROC,KTAG=KTAG,KERROR=IERROR)
      ENDIF
    ENDDO
  ELSE
    CALL MPL_RECV(KBUF,KSOURCE=IROOT,KTAG=KTAG,KERROR=IERROR)
  ENDIF
ELSE
  CALL MPI_BCAST(KBUF,ICOUNT,MPI_INTEGER,IROOT-1,ICOMM,IERROR)
ENDIF

IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_BROADCAST',CDSTRING,LDABORT=LLABORT)
ENDIF

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,L5,5I8)') ' MPL_BROADCAST ',LLCOMPAT,ICOUNT,IROOT,KTAG,ICOMM
ENDIF

END SUBROUTINE MPL_BROADCAST_INT_SCALAR

END MODULE MPL_BROADCAST_MOD
