MODULE MPL_ALLGATHER_MOD

!**** MPL_ALLGATHER Send data to all processes

!     Purpose.
!     --------
!     Send a message to all processes from a buffer.
!     The data may be REAL*4, REAL*8,or INTEGER, one dimensional array
!                     REAL*4,or REAL*8, two dimensional array
!                  or INTEGER scalar

!**   Interface.
!     ----------
!        CALL MPL_ALLGATHER

!        Input required arguments :
!        -------------------------
!           PSENDBUF -  buffer containing message
!                       (can be type REAL*4, REAL*8 or INTEGER)
!           PRECVBUF -  buffer containing message
!                       (can be type REAL*4, REAL*8 or INTEGER)
!           KRECVCOUNTS-number of elements received from each process

!        Input optional arguments :
!        -------------------------
!           KCOMM    -  Communicator number if different from MPI_COMM_WORLD 
!                       or from that established as the default 
!                       by an MPL communicator routine
!           KRECVDISPL -displacements in PRECVBUF at which to place 
!                       the incoming data
!           CDSTRING -  Character string for ABORT messages
!                       used when KERROR is not provided

!        Output required arguments :
!        -------------------------
!           none

!        Output optional arguments :
!        -------------------------
!           KERROR   -  return error code.     If not supplied, 
!                       MPL_ALLGATHER aborts when an error is detected.
!     Author.
!     -------
!        D.Dent, M.Hamrud     ECMWF

!     Modifications.
!     --------------
!        Original: 2000-11-23

!     ------------------------------------------------------------------

#include "tsmbkind.h"

USE MPL_MPIF
USE MPL_DATA_MODULE
USE MPL_MESSAGE_MOD
USE MPL_SEND_MOD
USE MPL_RECV_MOD
USE MPL_BARRIER_MOD

IMPLICIT NONE

PRIVATE

INTEGER_M :: IR,ISENDCOUNT,IRECVCOUNT,ICOMM,IERROR
LOGICAL :: LLABORT=.TRUE.
INTEGER_M :: ITAG
LOGICAL :: LLBARRIER
INTEGER_M :: IMAXMSG,JK,IMYPAIR,ICHUNKS,ISTS,ISTR,JMESS,ILENS,IENS,IOUNT
INTEGER_M :: ILIMIT,IBARRFREQ,IDUM

INTERFACE MPL_ALLGATHER
MODULE PROCEDURE MPL_ALLGATHER_REAL8,MPL_ALLGATHER_REAL4,MPL_ALLGATHER_INT,&
               & MPL_ALLGATHER_INT_SCALAR
END INTERFACE

PUBLIC MPL_ALLGATHER

CONTAINS

SUBROUTINE MPL_ALLGATHER_REAL4(PSENDBUF,PRECVBUF,KRECVCOUNTS,KRECVDISPL, &
                            & KCOMM,KERROR,CDSTRING)


REAL_M            :: PSENDBUF(:)
REAL_M            :: PRECVBUF(:)
INTEGER_M,INTENT(IN) :: KRECVCOUNTS(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: ICOMM,IERROR
INTEGER_M :: IRECVDISPL(SIZE(KRECVCOUNTS))

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_ALLGATHER: MPL NOT INITIALISED ',LDABORT=LLABORT) 
IF(SIZE(KRECVCOUNTS)  < MPL_NUMPROC) THEN
  WRITE(MPL_ERRUNIT,*)'MPL_ALLGATHER: ERROR KRECVCOUNTS dimension=',&
   & SIZE(KRECVCOUNTS)
  CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLGATHER: ERROR KRECVCOUNTS dimension is wrong',LDABORT=LLABORT)
ENDIF

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

ISENDCOUNT = SIZE(PSENDBUF)
IRECVCOUNT = SIZE(PRECVBUF)

IF(PRESENT(KRECVDISPL)) THEN
  IRECVDISPL(:) = KRECVDISPL(:)
ELSE
  IRECVDISPL(:) = 0
  DO IR=2, MPL_NUMPROC
    IRECVDISPL(IR) = IRECVDISPL(IR-1) + KRECVCOUNTS(IR-1)
  ENDDO
ENDIF
DO IR=1, MPL_NUMPROC
  IF(IRECVDISPL(IR)+KRECVCOUNTS(IR) > IRECVCOUNT) THEN
    WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLGATHER:RECV BUFFER TOO SMALL  ', &
     & IR,IRECVDISPL(IR),KRECVCOUNTS(IR),IRECVCOUNT
    CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
  ENDIF
ENDDO

!Tournament table exchange

IF(ICOMM == MPI_COMM_WORLD) THEN
  IERROR = 0
  PRECVBUF(IRECVDISPL(MPL_RANK)+1:IRECVDISPL(MPL_RANK)+KRECVCOUNTS(MPL_RANK)) = &
   & PSENDBUF(:)
  ILIMIT = 0.9*MPL_MBX_SIZE/4
  IMAXMSG = ILIMIT/2
  LLBARRIER = IRECVCOUNT>ILIMIT
  IBARRFREQ = MAX(1,ILIMIT/MAX(1,MAXVAL(KRECVCOUNTS))-1)
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  DO JK=1,MPL_NUMPROC
    IMYPAIR = MPL_OPPONENT(JK)
    IF(JK > 1 .AND. LLBARRIER) THEN
      IF(MOD(JK,IBARRFREQ) == 0) THEN
        CALL MPL_BARRIER(ICOMM,CDSTRING)
      ENDIF
    ENDIF
    IF(IMYPAIR == MPL_RANK .OR. IMYPAIR > MPL_NUMPROC) THEN
      CYCLE
    ENDIF
    ICHUNKS = (MAX(ISENDCOUNT,KRECVCOUNTS(IMYPAIR))-1)/IMAXMSG+1
    ISTS = 1
    ISTR = IRECVDISPL(IMYPAIR)+1
    DO JMESS=1,ICHUNKS
      ITAG = 1900+JMESS
      ILENS = MIN(ISENDCOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF(ILENS > 0) THEN
        CALL MPL_SEND(PSENDBUF(ISTS:IENS),KTAG=ITAG,KDEST=IMYPAIR,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
        ISTS = ISTS+ILENS
      ELSE
        CALL MPL_SEND(IDUM,KTAG=ITAG,KDEST=IMYPAIR,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
      ENDIF
      IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER(TT/SEND)',&
       & CDSTRING,LDABORT=LLABORT)
      IF(ISTR <= IRECVDISPL(IMYPAIR)+KRECVCOUNTS(IMYPAIR)) THEN
        CALL MPL_RECV(PRECVBUF(ISTR:),KTAG=ITAG,KSOURCE=IMYPAIR,KOUNT=IOUNT,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
        IF(ISTR+IOUNT-1 > IRECVDISPL(IMYPAIR)+KRECVCOUNTS(IMYPAIR)) THEN
          WRITE(MPL_ERRUNIT,'(A,5I10)')'WRONG  RECEIVE ', &
           & IMYPAIR,ISTR,IOUNT,IRECVDISPL(IMYPAIR),KRECVCOUNTS(IMYPAIR)
          CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
        ENDIF
        ISTR = ISTR+IOUNT
      ELSE
        CALL MPL_RECV(IDUM,KTAG=ITAG,KSOURCE=IMYPAIR,KOUNT=IOUNT,&
        & KERROR=IERROR,CDSTRING=CDSTRING)
        IF(IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,4I10)')'WRONG DUMMY RECEIVE ', &
           & IMYPAIR,IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER(TT/RECV)',&
       & CDSTRING,LDABORT=LLABORT)
    ENDDO
  ENDDO
ELSE

  CALL MPI_ALLGATHERV(PSENDBUF(1),ISENDCOUNT,MPI_REAL4,PRECVBUF(1),KRECVCOUNTS, &
   &  IRECVDISPL,MPI_REAL4,ICOMM,IERROR)
ENDIF

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,5I8)') ' MPL_ALLGATHER ',ISENDCOUNT,IRECVCOUNT,ICOMM
ENDIF
IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',&
   & CDSTRING,LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_ALLGATHER_REAL4

SUBROUTINE MPL_ALLGATHER_REAL8(PSENDBUF,PRECVBUF,KRECVCOUNTS,KRECVDISPL, &
                            & KCOMM,KERROR,CDSTRING)


REAL_B            :: PSENDBUF(:)
REAL_B            :: PRECVBUF(:)
INTEGER_M,INTENT(IN) :: KRECVCOUNTS(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: ICOMM,IERROR
INTEGER_M :: IRECVDISPL(SIZE(KRECVCOUNTS))

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_ALLGATHER: MPL NOT INITIALISED ',LDABORT=LLABORT) 
IF(SIZE(KRECVCOUNTS)  < MPL_NUMPROC) THEN
  WRITE(MPL_ERRUNIT,*)'MPL_ALLGATHER: ERROR KRECVCOUNTS dimension=',&
   & SIZE(KRECVCOUNTS)
  CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLGATHER: ERROR KRECVCOUNTS dimension is wrong',LDABORT=LLABORT)
ENDIF

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

ISENDCOUNT = SIZE(PSENDBUF)
IRECVCOUNT = SIZE(PRECVBUF)

IF(PRESENT(KRECVDISPL)) THEN
  IRECVDISPL(:) = KRECVDISPL(:)
ELSE
  IRECVDISPL(:) = 0
  DO IR=2, MPL_NUMPROC
    IRECVDISPL(IR) = IRECVDISPL(IR-1) + KRECVCOUNTS(IR-1)
  ENDDO
ENDIF
DO IR=1, MPL_NUMPROC
  IF(IRECVDISPL(IR)+KRECVCOUNTS(IR) > IRECVCOUNT) THEN
    WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLGATHER:RECV BUFFER TOO SMALL  ', &
     & IR,IRECVDISPL(IR),KRECVCOUNTS(IR),IRECVCOUNT
    CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
  ENDIF
ENDDO

!Tournament table exchange
IERROR=0
IF(ICOMM == MPI_COMM_WORLD) THEN
  IERROR = 0
  PRECVBUF(IRECVDISPL(MPL_RANK)+1:IRECVDISPL(MPL_RANK)+KRECVCOUNTS(MPL_RANK)) = &
   & PSENDBUF(:)
  ILIMIT = 0.9*MPL_MBX_SIZE/8
  IMAXMSG = ILIMIT/2
  LLBARRIER = IRECVCOUNT>ILIMIT
  IBARRFREQ = MAX(1,ILIMIT/MAX(1,MAXVAL(KRECVCOUNTS))-1)
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  DO JK=1,MPL_NUMPROC
    IMYPAIR = MPL_OPPONENT(JK)
    IF(JK > 1 .AND. LLBARRIER) THEN
      IF(MOD(JK,IBARRFREQ) == 0) THEN
        CALL MPL_BARRIER(ICOMM,CDSTRING)
      ENDIF
    ENDIF
    IF(IMYPAIR == MPL_RANK .OR. IMYPAIR > MPL_NUMPROC) THEN
      CYCLE
    ENDIF
    ICHUNKS = (MAX(ISENDCOUNT,KRECVCOUNTS(IMYPAIR))-1)/IMAXMSG+1
    ISTS = 1
    ISTR = IRECVDISPL(IMYPAIR)+1
    DO JMESS=1,ICHUNKS
      ITAG = 1900+JMESS
      ILENS = MIN(ISENDCOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF(ILENS > 0) THEN
        CALL MPL_SEND(PSENDBUF(ISTS:IENS),KTAG=ITAG,KDEST=IMYPAIR,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
        ISTS = ISTS+ILENS
      ELSE
        CALL MPL_SEND(IDUM,KTAG=ITAG,KDEST=IMYPAIR,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
      ENDIF
      IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER(TT/SEND)',& 
       & CDSTRING,LDABORT=LLABORT)
      IF(ISTR <= IRECVDISPL(IMYPAIR)+KRECVCOUNTS(IMYPAIR)) THEN
        CALL MPL_RECV(PRECVBUF(ISTR:),KTAG=ITAG,KSOURCE=IMYPAIR,KOUNT=IOUNT,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
        IF(ISTR+IOUNT-1 > IRECVDISPL(IMYPAIR)+KRECVCOUNTS(IMYPAIR)) THEN
          WRITE(MPL_ERRUNIT,'(A,5I10)')'WRONG  RECEIVE ', &
           & IMYPAIR,ISTR,IOUNT,IRECVDISPL(IMYPAIR),KRECVCOUNTS(IMYPAIR)
          CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
        ENDIF
        ISTR = ISTR+IOUNT
      ELSE
        CALL MPL_RECV(IDUM,KTAG=ITAG,KSOURCE=IMYPAIR,KOUNT=IOUNT,&
        & KERROR=IERROR,CDSTRING=CDSTRING)
        IF(IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,4I10)')'WRONG DUMMY RECEIVE ', &
           & IMYPAIR,IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER(TT/RECV)',&
       & CDSTRING,LDABORT=LLABORT)
    ENDDO
  ENDDO
ELSE
  CALL MPI_ALLGATHERV(PSENDBUF(1),ISENDCOUNT,MPI_REAL8,PRECVBUF(1),KRECVCOUNTS, &
                &  IRECVDISPL,MPI_REAL8,ICOMM,IERROR)
ENDIF

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,5I8)') ' MPL_ALLGATHER ',ISENDCOUNT,IRECVCOUNT,ICOMM
ENDIF
IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,&
   & LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_ALLGATHER_REAL8

SUBROUTINE MPL_ALLGATHER_INT(KSENDBUF,KRECVBUF,KRECVCOUNTS,KRECVDISPL, &
                            & KCOMM,KERROR,CDSTRING)


INTEGER_M         :: KSENDBUF(:)
INTEGER_M         :: KRECVBUF(:)
INTEGER_M,INTENT(IN) :: KRECVCOUNTS(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: ICOMM,IERROR
INTEGER_M :: IRECVDISPL(SIZE(KRECVCOUNTS))

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_ALLGATHER: MPL NOT INITIALISED ',LDABORT=LLABORT) 
IF(SIZE(KRECVCOUNTS)  < MPL_NUMPROC) THEN
  WRITE(MPL_ERRUNIT,*)'MPL_ALLGATHER: ERROR KRECVCOUNTS dimension=',&
   & SIZE(KRECVCOUNTS)
  CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLGATHER: ERROR KRECVCOUNTS dimension is wrong',LDABORT=LLABORT)
ENDIF

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

ISENDCOUNT = SIZE(KSENDBUF)
IRECVCOUNT = SIZE(KRECVBUF)

IF(PRESENT(KRECVDISPL)) THEN
  IRECVDISPL(:) = KRECVDISPL(:)
ELSE
  IRECVDISPL(:) = 0
  DO IR=2, MPL_NUMPROC
    IRECVDISPL(IR) = IRECVDISPL(IR-1) + KRECVCOUNTS(IR-1)
  ENDDO
ENDIF
DO IR=1, MPL_NUMPROC
  IF(IRECVDISPL(IR)+KRECVCOUNTS(IR) > IRECVCOUNT) THEN
    WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLGATHER:RECV BUFFER TOO SMALL  ', &
     & IR,IRECVDISPL(IR),KRECVCOUNTS(IR),IRECVCOUNT
    CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
  ENDIF
ENDDO

!Tournament table exchange
IERROR=0
IF(ICOMM == MPI_COMM_WORLD) THEN
  IERROR = 0
  KRECVBUF(IRECVDISPL(MPL_RANK)+1:IRECVDISPL(MPL_RANK)+KRECVCOUNTS(MPL_RANK)) = &
   & KSENDBUF(:)

  ILIMIT = 0.9*MPL_MBX_SIZE/4
  IMAXMSG = ILIMIT/2
  LLBARRIER = IRECVCOUNT>ILIMIT
  IBARRFREQ = MAX(1,ILIMIT/MAX(1,MAXVAL(KRECVCOUNTS))-1)
  CALL MPL_BARRIER(ICOMM,CDSTRING)
  DO JK=1,MPL_NUMPROC
    IMYPAIR = MPL_OPPONENT(JK)
    IF(JK > 1 .AND. LLBARRIER) THEN
      IF(MOD(JK,IBARRFREQ) == 0) THEN
        CALL MPL_BARRIER(ICOMM,CDSTRING)
      ENDIF
    ENDIF
    IF(IMYPAIR == MPL_RANK .OR. IMYPAIR > MPL_NUMPROC) THEN
      CYCLE
    ENDIF
    ICHUNKS = (MAX(ISENDCOUNT,KRECVCOUNTS(IMYPAIR))-1)/IMAXMSG+1
    ISTS = 1
    ISTR = IRECVDISPL(IMYPAIR)+1
    DO JMESS=1,ICHUNKS
      ITAG = 1900+JMESS
      ILENS = MIN(ISENDCOUNT-ISTS+1,IMAXMSG)
      IENS  = ISTS+ILENS-1
      IF(ILENS > 0) THEN
        CALL MPL_SEND(KSENDBUF(ISTS:IENS),KTAG=ITAG,KDEST=IMYPAIR,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
        ISTS = ISTS+ILENS
      ELSE
        CALL MPL_SEND(IDUM,KTAG=ITAG,KDEST=IMYPAIR,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
      ENDIF
      IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER(TT/SEND)', &
       & CDSTRING,LDABORT=LLABORT)
      IF(ISTR <= IRECVDISPL(IMYPAIR)+KRECVCOUNTS(IMYPAIR)) THEN
        CALL MPL_RECV(KRECVBUF(ISTR:),KTAG=ITAG,KSOURCE=IMYPAIR,KOUNT=IOUNT,&
         & KERROR=IERROR,CDSTRING=CDSTRING)
        IF(ISTR+IOUNT-1 > IRECVDISPL(IMYPAIR)+KRECVCOUNTS(IMYPAIR)) THEN
          WRITE(MPL_ERRUNIT,'(A,5I10)')'WRONG  RECEIVE ', &
           & IMYPAIR,ISTR,IOUNT,IRECVDISPL(IMYPAIR),KRECVCOUNTS(IMYPAIR)
          CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
        ENDIF
        ISTR = ISTR+IOUNT
      ELSE
        CALL MPL_RECV(IDUM,KTAG=ITAG,KSOURCE=IMYPAIR,KOUNT=IOUNT,&
        & KERROR=IERROR,CDSTRING=CDSTRING)
        IF(IOUNT /= 1) THEN
          WRITE(MPL_ERRUNIT,'(A,4I10)')'WRONG DUMMY RECEIVE ', &
           & IMYPAIR,IOUNT
          CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
        ENDIF
      ENDIF
      IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER(TT/RECV)',&
       & CDSTRING,LDABORT=LLABORT)
    ENDDO
  ENDDO
ELSE
  CALL MPI_ALLGATHERV(KSENDBUF(1),ISENDCOUNT,MPI_INTEGER,KRECVBUF(1),KRECVCOUNTS,&
   &  IRECVDISPL,MPI_INTEGER,ICOMM,IERROR)
ENDIF

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,5I8)') ' MPL_ALLGATHER ',ISENDCOUNT,IRECVCOUNT,ICOMM
ENDIF
IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_ALLGATHER_INT

SUBROUTINE MPL_ALLGATHER_INT_SCALAR(KSENDBUF,KRECVBUF,KRECVCOUNTS,KRECVDISPL, &
                            & KCOMM,KERROR,CDSTRING)


INTEGER_M         :: KSENDBUF
INTEGER_M         :: KRECVBUF(:)
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVCOUNTS(:) ! Not used; for compatibility only
INTEGER_M,INTENT(IN),OPTIONAL :: KRECVDISPL(:),KCOMM
INTEGER_M,INTENT(OUT),OPTIONAL :: KERROR
CHARACTER*(*),INTENT(IN),OPTIONAL :: CDSTRING

INTEGER_M :: ICOMM,IERROR
INTEGER_M :: IRECVDISPL(MPL_NUMPROC),IRECVCOUNTS(MPL_NUMPROC)

IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
  & CDMESSAGE='MPL_ALLGATHER: MPL NOT INITIALISED ',LDABORT=LLABORT) 

IF(PRESENT(KCOMM)) THEN
  ICOMM=KCOMM
ELSE
  ICOMM=MPL_COMM
ENDIF

ISENDCOUNT = 1
IRECVCOUNT = SIZE(KRECVBUF)

IRECVCOUNTS(:) = ISENDCOUNT
IF(PRESENT(KRECVDISPL)) THEN
  IRECVDISPL(:) = KRECVDISPL(:)
ELSE
  IRECVDISPL(:) = 0
  DO IR=2, MPL_NUMPROC
    IRECVDISPL(IR) = IRECVDISPL(IR-1) + ISENDCOUNT
  ENDDO
ENDIF
DO IR=1, MPL_NUMPROC
  IF(IRECVDISPL(IR)+1 > IRECVCOUNT) THEN
    WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLGATHER:RECV BUFFER TOO SMALL  ', &
     & IR,IRECVDISPL(IR),IRECVCOUNTS(IR),IRECVCOUNT
    CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
  ENDIF
ENDDO

CALL MPI_ALLGATHERV(KSENDBUF,ISENDCOUNT,MPI_INTEGER,KRECVBUF(1),IRECVCOUNTS,&
                &  IRECVDISPL,MPI_INTEGER,ICOMM,IERROR)

IF(MPL_OUTPUT > 1 )THEN
  WRITE(MPL_UNIT,'(A,5I8)') ' MPL_ALLGATHER ',ISENDCOUNT,IRECVCOUNT,ICOMM
ENDIF
IF(PRESENT(KERROR)) THEN
  KERROR=IERROR
ELSE
  IF(IERROR /= 0 ) CALL MPL_MESSAGE(IERROR,'MPL_ALLGATHER',CDSTRING,LDABORT=LLABORT)
ENDIF

END SUBROUTINE MPL_ALLGATHER_INT_SCALAR

END MODULE MPL_ALLGATHER_MOD
